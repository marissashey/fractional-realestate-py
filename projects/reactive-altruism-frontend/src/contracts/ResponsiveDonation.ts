/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'
import SimulateResponse = modelsv2.SimulateResponse

export const APP_SPEC: Arc56Contract = {"name":"ResponsiveDonation","structs":{"ConditionalClauseStruct":[{"name":"clauseId","type":"uint64"},{"name":"eventId","type":"uint64"},{"name":"payoutAmount","type":"uint64"},{"name":"recipientYes","type":"address"},{"name":"recipientNo","type":"address"},{"name":"donorAddress","type":"address"},{"name":"executed","type":"bool"}],"EventStruct":[{"name":"eventId","type":"uint64"},{"name":"eventString","type":"string"},{"name":"pending","type":"bool"},{"name":"resolution","type":"bool"},{"name":"oracleAddress","type":"address"}]},"methods":[{"name":"create_event","args":[{"type":"string","name":"event_string","desc":"Description of the event (e.g., \"Hurricane hits Miami\")"},{"type":"address","name":"oracle_address","desc":"Address authorized to resolve this event"}],"returns":{"type":"uint64","desc":"The event ID of the created event (uint64)"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Create a new event that can be used for conditional donations.","events":[],"recommendations":{}},{"name":"instantaneous_payout","args":[{"type":"address","name":"recipient_address","desc":"Address to receive the donation (charity/recipient)"},{"type":"pay","name":"payment","desc":"The payment transaction (must be grouped with the app call)"}],"returns":{"type":"bool","desc":"True if the donation is successful"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Process an immediate donation with instant payout to recipient.\nPerfect for direct charitable giving with immediate impact.","events":[],"recommendations":{}},{"name":"create_conditional_donation","args":[{"type":"uint64","name":"event_id","desc":"The event this donation depends on"},{"type":"address","name":"recipient_yes","desc":"Address to receive funds if event resolves to true"},{"type":"address","name":"recipient_no","desc":"Address to receive funds if event resolves to false (often donor)"},{"type":"pay","name":"payment","desc":"The payment transaction (funds held in escrow)"}],"returns":{"type":"uint64","desc":"The clause ID of the created conditional donation"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Create a conditional donation that will pay out based on event resolution.\nExample: \"Donate $1000 to Red Cross IF hurricane hits Miami, otherwise return to me\"","events":[],"recommendations":{}},{"name":"mixed_donation","args":[{"type":"address","name":"instant_recipient","desc":"Address to receive instant donation (use zero address if no instant donation)"},{"type":"uint64","name":"instant_amount","desc":"Amount for instant donation (use 0 if no instant donation)"},{"type":"uint64","name":"event_id","desc":"Event ID for conditional donation"},{"type":"address","name":"recipient_yes","desc":"Address to receive funds if event resolves to true"},{"type":"address","name":"recipient_no","desc":"Address to receive funds if event resolves to false"},{"type":"pay","name":"payment","desc":"The payment transaction covering both donations"}],"returns":{"type":"uint64","desc":"The clause ID for the conditional donation created"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Create both instantaneous and conditional donations in a single transaction.\nSimplified version that handles one conditional donation to keep it simple.","events":[],"recommendations":{}},{"name":"resolve_event","args":[{"type":"uint64","name":"event_id","desc":"The event to resolve"},{"type":"bool","name":"resolution","desc":"The outcome of the event (true/false)"}],"returns":{"type":"bool","desc":"True if the event is successfully resolved"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Resolve an event outcome. Can only be called by the authorized oracle.","events":[],"recommendations":{}},{"name":"execute_conditional_clause","args":[{"type":"uint64","name":"clause_id","desc":"The clause to execute"}],"returns":{"type":"bool","desc":"True if the clause is successfully executed"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Execute a conditional clause after its associated event has been resolved.\nCan be called by anyone to trigger payouts.","events":[],"recommendations":{}},{"name":"execute_clauses_for_event","args":[{"type":"uint64","name":"event_id","desc":"The event whose clauses should be executed"}],"returns":{"type":"uint64","desc":"Number of clauses executed"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Execute all unexecuted conditional clauses for a resolved event.\nThis is more gas-efficient than executing clauses one by one.","events":[],"recommendations":{}},{"name":"get_event_info","args":[{"type":"uint64","name":"event_id","desc":"The event ID to query"}],"returns":{"type":"(uint64,string,bool,bool,address)","struct":"EventStruct","desc":"The EventStruct containing the event's information"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Get information about an event.","events":[],"recommendations":{}},{"name":"get_clause_info","args":[{"type":"uint64","name":"clause_id","desc":"The clause ID to query"}],"returns":{"type":"(uint64,uint64,uint64,address,address,address,bool)","struct":"ConditionalClauseStruct","desc":"The ConditionalClauseStruct containing the clause's information"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Get information about a conditional clause.","events":[],"recommendations":{}},{"name":"get_pending_events","args":[],"returns":{"type":"uint64[]","desc":"Array of pending event IDs (empty for now - placeholder for interface)"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Get all pending event IDs. Oracle can use this to know which events to monitor.\nNote: This is a simplified version - in production you'd want pagination for large numbers of events.","events":[],"recommendations":{}},{"name":"get_clauses_for_event","args":[{"type":"uint64","name":"event_id","desc":"The event to get clauses for"}],"returns":{"type":"uint64[]","desc":"Array of clause IDs that depend on this event"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Get all clause IDs that depend on a specific event.\nOracle can call this when resolving an event to get all clauses to execute.","events":[],"recommendations":{}}],"arcs":[22,28],"desc":"\n    ResponsiveDonation Contract - MVP Version\n    \n    A smart contract enabling conditional charitable donations based on real-world events.\n    Perfect for disaster relief, climate action, and cause-based giving.\n    \n    Core Features:\n    1. ðŸ’° Instantaneous Donations - Direct donations with immediate payout\n    2. ðŸŽ¯ Conditional Donations - \"Donate $1000 to Red Cross IF hurricane hits Miami\"\n    3. ðŸ”® Oracle Resolution - Trusted oracles resolve event outcomes\n    4. ðŸš€ Mixed Donations - Combine instant + conditional in one transaction\n    5. ðŸ“Š Query Interface - Discover events and clauses\n    \n    Use Cases:\n    - Climate disaster relief (donate if hurricane/wildfire occurs)\n    - Charity matching (donate if fundraising goal is met)\n    - Sports betting for good (donate to charity if team wins)\n    - Political action (donate if legislation passes)\n    ","networks":{},"state":{"schema":{"global":{"ints":0,"bytes":0},"local":{"ints":0,"bytes":0}},"keys":{"global":{},"local":{},"box":{}},"maps":{"global":{},"local":{},"box":{"listed_events":{"keyType":"uint64","valueType":"EventStruct","prefix":"ZXZlbnRz"},"conditional_clauses":{"keyType":"uint64","valueType":"ConditionalClauseStruct","prefix":"Y2xhdXNlcw=="},"event_clauses":{"keyType":"uint64","valueType":"uint64[]","prefix":"ZXZlbnRfY2xhdXNlcw=="}}}},"bareActions":{"create":["NoOp"],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[948],"errorMessage":"Associated event does not exist"},{"pc":[918,1260],"errorMessage":"Clause does not exist"},{"pc":[937],"errorMessage":"Clause has already been executed"},{"pc":[702],"errorMessage":"Conditional amount must be greater than 0"},{"pc":[531,737,865,1037,1245],"errorMessage":"Event does not exist"},{"pc":[543,749,879],"errorMessage":"Event has already been resolved"},{"pc":[962,1054],"errorMessage":"Event has not been resolved yet"},{"pc":[884,938,977,1014,1113,1169,1223],"errorMessage":"Index access is out of bounds"},{"pc":[503],"errorMessage":"Minimum donation is 1000 microAlgos (0.001 ALGO)"},{"pc":[153,172,190,209,228,247,271,298,339,374,408],"errorMessage":"OnCompletion is not NoOp"},{"pc":[888],"errorMessage":"Only authorized oracle can resolve event"},{"pc":[497,565,687],"errorMessage":"Payment amount must be greater than 0"},{"pc":[709],"errorMessage":"Payment amount must equal sum of donations"},{"pc":[483,551,673],"errorMessage":"Payment must be sent to contract"},{"pc":[491,559,681],"errorMessage":"Payment sender must match transaction sender"},{"pc":[435],"errorMessage":"can only call when creating"},{"pc":[156,175,193,212,231,250,274,301,342,377,411],"errorMessage":"can only call when not creating"},{"pc":[924,1139,1262],"errorMessage":"check self.conditional_clauses entry exists"},{"pc":[624,811,1081,1282],"errorMessage":"check self.event_clauses entry exists"},{"pc":[533,739,868,950,1043,1247],"errorMessage":"check self.listed_events entry exists"},{"pc":[326,361,390],"errorMessage":"transaction type is pay"}],"pcOffsetMethod":"none"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBzbWFydF9jb250cmFjdHMucmVzcG9uc2l2ZV9kb25hdGlvbi5jb250cmFjdC5SZXNwb25zaXZlRG9uYXRpb24uX19hbGdvcHlfZW50cnlwb2ludF93aXRoX2luaXQoKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDgwIDgxIDk2MAogICAgYnl0ZWNibG9jayAweDAwIDB4MTUxZjdjNzUgImV2ZW50cyIgImNsYXVzZXMiICJldmVudF9jbGF1c2VzIiAweDAwMDEgMHgwMDAwMDAwMDAwMDAwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo2MQogICAgLy8gY2xhc3MgUmVzcG9uc2l2ZURvbmF0aW9uKEFSQzRDb250cmFjdCk6CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9iYXJlX3JvdXRpbmdAMTYKICAgIHB1c2hieXRlc3MgMHg5NjNlOTJlZiAweDg0OGRiZTUyIDB4MTIwNmQ4ZmQgMHhhNmZlZDM0NCAweDJkYjY5OTQ2IDB4YjVhMTY3Y2EgMHgxNTNhNTI1YyAweGI4NGUxNWQ2IDB4NzY1ZTBmM2YgMHhjODlkZDkwMiAweDJjMWQ2ZDE3IC8vIG1ldGhvZCAiY3JlYXRlX2V2ZW50KHN0cmluZyxhZGRyZXNzKXVpbnQ2NCIsIG1ldGhvZCAiaW5zdGFudGFuZW91c19wYXlvdXQoYWRkcmVzcyxwYXkpYm9vbCIsIG1ldGhvZCAiY3JlYXRlX2NvbmRpdGlvbmFsX2RvbmF0aW9uKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MscGF5KXVpbnQ2NCIsIG1ldGhvZCAibWl4ZWRfZG9uYXRpb24oYWRkcmVzcyx1aW50NjQsdWludDY0LGFkZHJlc3MsYWRkcmVzcyxwYXkpdWludDY0IiwgbWV0aG9kICJyZXNvbHZlX2V2ZW50KHVpbnQ2NCxib29sKWJvb2wiLCBtZXRob2QgImV4ZWN1dGVfY29uZGl0aW9uYWxfY2xhdXNlKHVpbnQ2NClib29sIiwgbWV0aG9kICJleGVjdXRlX2NsYXVzZXNfZm9yX2V2ZW50KHVpbnQ2NCl1aW50NjQiLCBtZXRob2QgImdldF9ldmVudF9pbmZvKHVpbnQ2NCkodWludDY0LHN0cmluZyxib29sLGJvb2wsYWRkcmVzcykiLCBtZXRob2QgImdldF9jbGF1c2VfaW5mbyh1aW50NjQpKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsYWRkcmVzcyxhZGRyZXNzLGJvb2wpIiwgbWV0aG9kICJnZXRfcGVuZGluZ19ldmVudHMoKXVpbnQ2NFtdIiwgbWV0aG9kICJnZXRfY2xhdXNlc19mb3JfZXZlbnQodWludDY0KXVpbnQ2NFtdIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggbWFpbl9jcmVhdGVfZXZlbnRfcm91dGVANSBtYWluX2luc3RhbnRhbmVvdXNfcGF5b3V0X3JvdXRlQDYgbWFpbl9jcmVhdGVfY29uZGl0aW9uYWxfZG9uYXRpb25fcm91dGVANyBtYWluX21peGVkX2RvbmF0aW9uX3JvdXRlQDggbWFpbl9yZXNvbHZlX2V2ZW50X3JvdXRlQDkgbWFpbl9leGVjdXRlX2NvbmRpdGlvbmFsX2NsYXVzZV9yb3V0ZUAxMCBtYWluX2V4ZWN1dGVfY2xhdXNlc19mb3JfZXZlbnRfcm91dGVAMTEgbWFpbl9nZXRfZXZlbnRfaW5mb19yb3V0ZUAxMiBtYWluX2dldF9jbGF1c2VfaW5mb19yb3V0ZUAxMyBtYWluX2dldF9wZW5kaW5nX2V2ZW50c19yb3V0ZUAxNCBtYWluX2dldF9jbGF1c2VzX2Zvcl9ldmVudF9yb3V0ZUAxNQoKbWFpbl9hZnRlcl9pZl9lbHNlQDE4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NjEKICAgIC8vIGNsYXNzIFJlc3BvbnNpdmVEb25hdGlvbihBUkM0Q29udHJhY3QpOgogICAgaW50Y18wIC8vIDAKICAgIHJldHVybgoKbWFpbl9nZXRfY2xhdXNlc19mb3JfZXZlbnRfcm91dGVAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo0OTQKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NjEKICAgIC8vIGNsYXNzIFJlc3BvbnNpdmVEb25hdGlvbihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDk0CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBjYWxsc3ViIGdldF9jbGF1c2VzX2Zvcl9ldmVudAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9nZXRfcGVuZGluZ19ldmVudHNfcm91dGVAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo0NzYKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzUwMDAwCiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ2V0X2NsYXVzZV9pbmZvX3JvdXRlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDU5CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjYxCiAgICAvLyBjbGFzcyBSZXNwb25zaXZlRG9uYXRpb24oQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjQ1OQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBnZXRfY2xhdXNlX2luZm8KICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ2V0X2V2ZW50X2luZm9fcm91dGVAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo0NDIKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NjEKICAgIC8vIGNsYXNzIFJlc3BvbnNpdmVEb25hdGlvbihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDQyCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBjYWxsc3ViIGdldF9ldmVudF9pbmZvCiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2V4ZWN1dGVfY2xhdXNlc19mb3JfZXZlbnRfcm91dGVAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTozODMKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo2MQogICAgLy8gY2xhc3MgUmVzcG9uc2l2ZURvbmF0aW9uKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTozODMKICAgIC8vIEBhYmltZXRob2QoKQogICAgY2FsbHN1YiBleGVjdXRlX2NsYXVzZXNfZm9yX2V2ZW50CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2V4ZWN1dGVfY29uZGl0aW9uYWxfY2xhdXNlX3JvdXRlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MzM0CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NjEKICAgIC8vIGNsYXNzIFJlc3BvbnNpdmVEb25hdGlvbihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MzM0CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgZXhlY3V0ZV9jb25kaXRpb25hbF9jbGF1c2UKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3Jlc29sdmVfZXZlbnRfcm91dGVAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjMwMAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjYxCiAgICAvLyBjbGFzcyBSZXNwb25zaXZlRG9uYXRpb24oQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjMwMAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIHJlc29sdmVfZXZlbnQKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX21peGVkX2RvbmF0aW9uX3JvdXRlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyMjQKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo2MQogICAgLy8gY2xhc3MgUmVzcG9uc2l2ZURvbmF0aW9uKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjIyNAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIG1peGVkX2RvbmF0aW9uCiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZV9jb25kaXRpb25hbF9kb25hdGlvbl9yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTY2CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NjEKICAgIC8vIGNsYXNzIFJlc3BvbnNpdmVEb25hdGlvbihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNjYKICAgIC8vIEBhYmltZXRob2QoKQogICAgY2FsbHN1YiBjcmVhdGVfY29uZGl0aW9uYWxfZG9uYXRpb24KICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faW5zdGFudGFuZW91c19wYXlvdXRfcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjEzNAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjYxCiAgICAvLyBjbGFzcyBSZXNwb25zaXZlRG9uYXRpb24oQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTM0CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgaW5zdGFudGFuZW91c19wYXlvdXQKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZV9ldmVudF9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTA0CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NjEKICAgIC8vIGNsYXNzIFJlc3BvbnNpdmVEb25hdGlvbihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTA0CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY3JlYXRlX2V2ZW50CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2JhcmVfcm91dGluZ0AxNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjYxCiAgICAvLyBjbGFzcyBSZXNwb25zaXZlRG9uYXRpb24oQVJDNENvbnRyYWN0KToKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIGJueiBtYWluX2FmdGVyX2lmX2Vsc2VAMTgKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLnJlc3BvbnNpdmVfZG9uYXRpb24uY29udHJhY3QuUmVzcG9uc2l2ZURvbmF0aW9uLmNyZWF0ZV9ldmVudChldmVudF9zdHJpbmc6IGJ5dGVzLCBvcmFjbGVfYWRkcmVzczogYnl0ZXMpIC0+IGJ5dGVzOgpjcmVhdGVfZXZlbnQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxMDQtMTA5CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjcmVhdGVfZXZlbnQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBldmVudF9zdHJpbmc6IGFyYzQuU3RyaW5nLAogICAgLy8gICAgIG9yYWNsZV9hZGRyZXNzOiBhcmM0LkFkZHJlc3MKICAgIC8vICkgLT4gYXJjNC5VSW50NjQ6CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjEyMC0xMjEKICAgIC8vICMgVXNlIHRpbWVzdGFtcCBhcyB1bmlxdWUgZXZlbnQgSUQKICAgIC8vIGV2ZW50X2lkID0gYXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxMjMtMTMwCiAgICAvLyAjIENyZWF0ZSBhbmQgc3RvcmUgdGhlIGV2ZW50IHN0cnVjdAogICAgLy8gc2VsZi5saXN0ZWRfZXZlbnRzW2V2ZW50X2lkXSA9IEV2ZW50U3RydWN0KAogICAgLy8gICAgIGV2ZW50X2lkPWV2ZW50X2lkLAogICAgLy8gICAgIGV2ZW50X3N0cmluZz1ldmVudF9zdHJpbmcsCiAgICAvLyAgICAgcGVuZGluZz1hcmM0LkJvb2woVHJ1ZSksCiAgICAvLyAgICAgcmVzb2x1dGlvbj1hcmM0LkJvb2woRmFsc2UpLCAgIyBEZWZhdWx0IHJlc29sdXRpb24sIG5vdCBtZWFuaW5nZnVsIHVudGlsIHBlbmRpbmc9ZmFsc2UKICAgIC8vICAgICBvcmFjbGVfYWRkcmVzcz1vcmFjbGVfYWRkcmVzcwogICAgLy8gKQogICAgZHVwCiAgICBwdXNoYnl0ZXMgMHgwMDJiCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjEyNwogICAgLy8gcGVuZGluZz1hcmM0LkJvb2woVHJ1ZSksCiAgICBwdXNoYnl0ZXMgMHg4MAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTIzLTEzMAogICAgLy8gIyBDcmVhdGUgYW5kIHN0b3JlIHRoZSBldmVudCBzdHJ1Y3QKICAgIC8vIHNlbGYubGlzdGVkX2V2ZW50c1tldmVudF9pZF0gPSBFdmVudFN0cnVjdCgKICAgIC8vICAgICBldmVudF9pZD1ldmVudF9pZCwKICAgIC8vICAgICBldmVudF9zdHJpbmc9ZXZlbnRfc3RyaW5nLAogICAgLy8gICAgIHBlbmRpbmc9YXJjNC5Cb29sKFRydWUpLAogICAgLy8gICAgIHJlc29sdXRpb249YXJjNC5Cb29sKEZhbHNlKSwgICMgRGVmYXVsdCByZXNvbHV0aW9uLCBub3QgbWVhbmluZ2Z1bCB1bnRpbCBwZW5kaW5nPWZhbHNlCiAgICAvLyAgICAgb3JhY2xlX2FkZHJlc3M9b3JhY2xlX2FkZHJlc3MKICAgIC8vICkKICAgIGNvbmNhdAogICAgaW50Y18zIC8vIDgxCiAgICBpbnRjXzAgLy8gMAogICAgc2V0Yml0CiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjEyMy0xMjQKICAgIC8vICMgQ3JlYXRlIGFuZCBzdG9yZSB0aGUgZXZlbnQgc3RydWN0CiAgICAvLyBzZWxmLmxpc3RlZF9ldmVudHNbZXZlbnRfaWRdID0gRXZlbnRTdHJ1Y3QoCiAgICBieXRlY18yIC8vICJldmVudHMiCiAgICBkaWcgMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxMjMtMTMwCiAgICAvLyAjIENyZWF0ZSBhbmQgc3RvcmUgdGhlIGV2ZW50IHN0cnVjdAogICAgLy8gc2VsZi5saXN0ZWRfZXZlbnRzW2V2ZW50X2lkXSA9IEV2ZW50U3RydWN0KAogICAgLy8gICAgIGV2ZW50X2lkPWV2ZW50X2lkLAogICAgLy8gICAgIGV2ZW50X3N0cmluZz1ldmVudF9zdHJpbmcsCiAgICAvLyAgICAgcGVuZGluZz1hcmM0LkJvb2woVHJ1ZSksCiAgICAvLyAgICAgcmVzb2x1dGlvbj1hcmM0LkJvb2woRmFsc2UpLCAgIyBEZWZhdWx0IHJlc29sdXRpb24sIG5vdCBtZWFuaW5nZnVsIHVudGlsIHBlbmRpbmc9ZmFsc2UKICAgIC8vICAgICBvcmFjbGVfYWRkcmVzcz1vcmFjbGVfYWRkcmVzcwogICAgLy8gKQogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjEzMgogICAgLy8gcmV0dXJuIGV2ZW50X2lkCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMucmVzcG9uc2l2ZV9kb25hdGlvbi5jb250cmFjdC5SZXNwb25zaXZlRG9uYXRpb24uaW5zdGFudGFuZW91c19wYXlvdXQocmVjaXBpZW50X2FkZHJlc3M6IGJ5dGVzLCBwYXltZW50OiB1aW50NjQpIC0+IHVpbnQ2NDoKaW5zdGFudGFuZW91c19wYXlvdXQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxMzQtMTM5CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBpbnN0YW50YW5lb3VzX3BheW91dCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHJlY2lwaWVudF9hZGRyZXNzOiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgcGF5bWVudDogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24KICAgIC8vICkgLT4gYm9vbDoKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTUxLTE1MgogICAgLy8gIyBWYWxpZGF0ZSB0aGUgcGF5bWVudCB0cmFuc2FjdGlvbgogICAgLy8gYXNzZXJ0IHBheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywgIlBheW1lbnQgbXVzdCBiZSBzZW50IHRvIGNvbnRyYWN0IgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gUGF5bWVudCBtdXN0IGJlIHNlbnQgdG8gY29udHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjE1MwogICAgLy8gYXNzZXJ0IHBheW1lbnQuc2VuZGVyID09IFR4bi5zZW5kZXIsICJQYXltZW50IHNlbmRlciBtdXN0IG1hdGNoIHRyYW5zYWN0aW9uIHNlbmRlciIKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgU2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICA9PQogICAgYXNzZXJ0IC8vIFBheW1lbnQgc2VuZGVyIG11c3QgbWF0Y2ggdHJhbnNhY3Rpb24gc2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNTQKICAgIC8vIGFzc2VydCBwYXltZW50LmFtb3VudCA+IDAsICJQYXltZW50IGFtb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBbW91bnQKICAgIGR1cAogICAgYXNzZXJ0IC8vIFBheW1lbnQgYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjE1NQogICAgLy8gYXNzZXJ0IHBheW1lbnQuYW1vdW50ID49IDEwMDAsICJNaW5pbXVtIGRvbmF0aW9uIGlzIDEwMDAgbWljcm9BbGdvcyAoMC4wMDEgQUxHTykiCiAgICBkdXAKICAgIHB1c2hpbnQgMTAwMCAvLyAxMDAwCiAgICA+PQogICAgYXNzZXJ0IC8vIE1pbmltdW0gZG9uYXRpb24gaXMgMTAwMCBtaWNyb0FsZ29zICgwLjAwMSBBTEdPKQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTU3LTE2MgogICAgLy8gIyBJbW1lZGlhdGVseSB0cmFuc2ZlciB0aGUgZnVuZHMgdG8gdGhlIHJlY2lwaWVudAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIGFtb3VudD1wYXltZW50LmFtb3VudCwKICAgIC8vICAgICByZWNlaXZlcj1yZWNpcGllbnRfYWRkcmVzcy5uYXRpdmUsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNTctMTU4CiAgICAvLyAjIEltbWVkaWF0ZWx5IHRyYW5zZmVyIHRoZSBmdW5kcyB0byB0aGUgcmVjaXBpZW50CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNjEKICAgIC8vIGZlZT0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNTctMTYyCiAgICAvLyAjIEltbWVkaWF0ZWx5IHRyYW5zZmVyIHRoZSBmdW5kcyB0byB0aGUgcmVjaXBpZW50CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgYW1vdW50PXBheW1lbnQuYW1vdW50LAogICAgLy8gICAgIHJlY2VpdmVyPXJlY2lwaWVudF9hZGRyZXNzLm5hdGl2ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNjQKICAgIC8vIHJldHVybiBUcnVlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnJlc3BvbnNpdmVfZG9uYXRpb24uY29udHJhY3QuUmVzcG9uc2l2ZURvbmF0aW9uLmNyZWF0ZV9jb25kaXRpb25hbF9kb25hdGlvbihldmVudF9pZDogYnl0ZXMsIHJlY2lwaWVudF95ZXM6IGJ5dGVzLCByZWNpcGllbnRfbm86IGJ5dGVzLCBwYXltZW50OiB1aW50NjQpIC0+IGJ5dGVzOgpjcmVhdGVfY29uZGl0aW9uYWxfZG9uYXRpb246CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNjYtMTczCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjcmVhdGVfY29uZGl0aW9uYWxfZG9uYXRpb24oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBldmVudF9pZDogYXJjNC5VSW50NjQsCiAgICAvLyAgICAgcmVjaXBpZW50X3llczogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIHJlY2lwaWVudF9ubzogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIHBheW1lbnQ6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gNCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxODctMTg4CiAgICAvLyAjIEVuc3VyZSB0aGUgZXZlbnQgZXhpc3RzIGFuZCBpcyBzdGlsbCBwZW5kaW5nCiAgICAvLyBhc3NlcnQgZXZlbnRfaWQgaW4gc2VsZi5saXN0ZWRfZXZlbnRzLCAiRXZlbnQgZG9lcyBub3QgZXhpc3QiCiAgICBieXRlY18yIC8vICJldmVudHMiCiAgICBmcmFtZV9kaWcgLTQKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBFdmVudCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTg5CiAgICAvLyBldmVudF9zdHJ1Y3QgPSBzZWxmLmxpc3RlZF9ldmVudHNbZXZlbnRfaWRdLmNvcHkoKQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubGlzdGVkX2V2ZW50cyBlbnRyeSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjE5MAogICAgLy8gYXNzZXJ0IGV2ZW50X3N0cnVjdC5wZW5kaW5nLm5hdGl2ZSwgIkV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQiCiAgICBpbnRjXzIgLy8gODAKICAgIGdldGJpdAogICAgYnl0ZWNfMCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGFzc2VydCAvLyBFdmVudCBoYXMgYWxyZWFkeSBiZWVuIHJlc29sdmVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxOTItMTkzCiAgICAvLyAjIFZhbGlkYXRlIHRoZSBwYXltZW50IHRyYW5zYWN0aW9uCiAgICAvLyBhc3NlcnQgcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLCAiUGF5bWVudCBtdXN0IGJlIHNlbnQgdG8gY29udHJhY3QiCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBQYXltZW50IG11c3QgYmUgc2VudCB0byBjb250cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTk0CiAgICAvLyBhc3NlcnQgcGF5bWVudC5zZW5kZXIgPT0gVHhuLnNlbmRlciwgIlBheW1lbnQgc2VuZGVyIG11c3QgbWF0Y2ggdHJhbnNhY3Rpb24gc2VuZGVyIgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBTZW5kZXIKICAgIHR4biBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gUGF5bWVudCBzZW5kZXIgbXVzdCBtYXRjaCB0cmFuc2FjdGlvbiBzZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjE5NQogICAgLy8gYXNzZXJ0IHBheW1lbnQuYW1vdW50ID4gMCwgIlBheW1lbnQgYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAiCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgZHVwCiAgICBhc3NlcnQgLy8gUGF5bWVudCBhbW91bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTk3LTE5OAogICAgLy8gIyBVc2UgdGltZXN0YW1wICsgaGFzaCBvZiBzZW5kZXIgZm9yIHVuaXF1ZSBjbGF1c2UgSUQgdG8gYXZvaWQgY29sbGlzaW9ucwogICAgLy8gc2VuZGVyX2hhc2ggPSBvcC5zaGEyNTYoVHhuLnNlbmRlci5ieXRlcykKICAgIHR4biBTZW5kZXIKICAgIHNoYTI1NgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTk5CiAgICAvLyBjbGF1c2VfaWQgPSBhcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCArIG9wLmJ0b2koc2VuZGVyX2hhc2hbOjhdKSkKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIHN3YXAKICAgIHN1YnN0cmluZyAwIDgKICAgIGJ0b2kKICAgICsKICAgIGl0b2IKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyMDUKICAgIC8vIHBheW91dF9hbW91bnQ9YXJjNC5VSW50NjQocGF5bWVudC5hbW91bnQpLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjA4CiAgICAvLyBkb25vcl9hZGRyZXNzPWFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjIwMS0yMTAKICAgIC8vICMgQ3JlYXRlIGFuZCBzdG9yZSB0aGUgY29uZGl0aW9uYWwgY2xhdXNlCiAgICAvLyBzZWxmLmNvbmRpdGlvbmFsX2NsYXVzZXNbY2xhdXNlX2lkXSA9IENvbmRpdGlvbmFsQ2xhdXNlU3RydWN0KAogICAgLy8gICAgIGNsYXVzZV9pZD1jbGF1c2VfaWQsCiAgICAvLyAgICAgZXZlbnRfaWQ9ZXZlbnRfaWQsCiAgICAvLyAgICAgcGF5b3V0X2Ftb3VudD1hcmM0LlVJbnQ2NChwYXltZW50LmFtb3VudCksCiAgICAvLyAgICAgcmVjaXBpZW50X3llcz1yZWNpcGllbnRfeWVzLAogICAgLy8gICAgIHJlY2lwaWVudF9ubz1yZWNpcGllbnRfbm8sCiAgICAvLyAgICAgZG9ub3JfYWRkcmVzcz1hcmM0LkFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgICAgZXhlY3V0ZWQ9YXJjNC5Cb29sKEZhbHNlKQogICAgLy8gKQogICAgZGlnIDIKICAgIGZyYW1lX2RpZyAtNAogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0zCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjIwOQogICAgLy8gZXhlY3V0ZWQ9YXJjNC5Cb29sKEZhbHNlKQogICAgYnl0ZWNfMCAvLyAweDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyMDEtMjEwCiAgICAvLyAjIENyZWF0ZSBhbmQgc3RvcmUgdGhlIGNvbmRpdGlvbmFsIGNsYXVzZQogICAgLy8gc2VsZi5jb25kaXRpb25hbF9jbGF1c2VzW2NsYXVzZV9pZF0gPSBDb25kaXRpb25hbENsYXVzZVN0cnVjdCgKICAgIC8vICAgICBjbGF1c2VfaWQ9Y2xhdXNlX2lkLAogICAgLy8gICAgIGV2ZW50X2lkPWV2ZW50X2lkLAogICAgLy8gICAgIHBheW91dF9hbW91bnQ9YXJjNC5VSW50NjQocGF5bWVudC5hbW91bnQpLAogICAgLy8gICAgIHJlY2lwaWVudF95ZXM9cmVjaXBpZW50X3llcywKICAgIC8vICAgICByZWNpcGllbnRfbm89cmVjaXBpZW50X25vLAogICAgLy8gICAgIGRvbm9yX2FkZHJlc3M9YXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIGV4ZWN1dGVkPWFyYzQuQm9vbChGYWxzZSkKICAgIC8vICkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjAxLTIwMgogICAgLy8gIyBDcmVhdGUgYW5kIHN0b3JlIHRoZSBjb25kaXRpb25hbCBjbGF1c2UKICAgIC8vIHNlbGYuY29uZGl0aW9uYWxfY2xhdXNlc1tjbGF1c2VfaWRdID0gQ29uZGl0aW9uYWxDbGF1c2VTdHJ1Y3QoCiAgICBieXRlY18zIC8vICJjbGF1c2VzIgogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjIwMS0yMTAKICAgIC8vICMgQ3JlYXRlIGFuZCBzdG9yZSB0aGUgY29uZGl0aW9uYWwgY2xhdXNlCiAgICAvLyBzZWxmLmNvbmRpdGlvbmFsX2NsYXVzZXNbY2xhdXNlX2lkXSA9IENvbmRpdGlvbmFsQ2xhdXNlU3RydWN0KAogICAgLy8gICAgIGNsYXVzZV9pZD1jbGF1c2VfaWQsCiAgICAvLyAgICAgZXZlbnRfaWQ9ZXZlbnRfaWQsCiAgICAvLyAgICAgcGF5b3V0X2Ftb3VudD1hcmM0LlVJbnQ2NChwYXltZW50LmFtb3VudCksCiAgICAvLyAgICAgcmVjaXBpZW50X3llcz1yZWNpcGllbnRfeWVzLAogICAgLy8gICAgIHJlY2lwaWVudF9ubz1yZWNpcGllbnRfbm8sCiAgICAvLyAgICAgZG9ub3JfYWRkcmVzcz1hcmM0LkFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgICAgZXhlY3V0ZWQ9YXJjNC5Cb29sKEZhbHNlKQogICAgLy8gKQogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjEyLTIxMwogICAgLy8gIyBBZGQgY2xhdXNlIHRvIGV2ZW50IGluZGV4IGZvciBlZmZpY2llbnQgbG9va3VwCiAgICAvLyBpZiBldmVudF9pZCBpbiBzZWxmLmV2ZW50X2NsYXVzZXM6CiAgICBieXRlYyA0IC8vICJldmVudF9jbGF1c2VzIgogICAgZnJhbWVfZGlnIC00CiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBieiBjcmVhdGVfY29uZGl0aW9uYWxfZG9uYXRpb25fZWxzZV9ib2R5QDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjIxNAogICAgLy8gZXhpc3RpbmdfY2xhdXNlcyA9IHNlbGYuZXZlbnRfY2xhdXNlc1tldmVudF9pZF0uY29weSgpCiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ldmVudF9jbGF1c2VzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjE1CiAgICAvLyBleGlzdGluZ19jbGF1c2VzLmFwcGVuZChjbGF1c2VfaWQpCiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIDAKICAgIGNvbmNhdAogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgOCAvLyA4CiAgICAvCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyMTYKICAgIC8vIHNlbGYuZXZlbnRfY2xhdXNlc1tldmVudF9pZF0gPSBleGlzdGluZ19jbGF1c2VzLmNvcHkoKQogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjIyCiAgICAvLyByZXR1cm4gY2xhdXNlX2lkCiAgICByZXRzdWIKCmNyZWF0ZV9jb25kaXRpb25hbF9kb25hdGlvbl9lbHNlX2JvZHlAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjIxOC0yMTkKICAgIC8vICMgQ3JlYXRlIG5ldyBhcnJheSB3aXRoIHRoaXMgY2xhdXNlCiAgICAvLyBuZXdfY2xhdXNlX2FycmF5ID0gYXJjNC5EeW5hbWljQXJyYXlbYXJjNC5VSW50NjRdKGNsYXVzZV9pZCkKICAgIGJ5dGVjIDUgLy8gMHgwMDAxCiAgICBmcmFtZV9kaWcgMAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyMjAKICAgIC8vIHNlbGYuZXZlbnRfY2xhdXNlc1tldmVudF9pZF0gPSBuZXdfY2xhdXNlX2FycmF5LmNvcHkoKQogICAgZnJhbWVfZGlnIDEKICAgIGR1cAogICAgYm94X2RlbAogICAgcG9wCiAgICBzd2FwCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyMjIKICAgIC8vIHJldHVybiBjbGF1c2VfaWQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5yZXNwb25zaXZlX2RvbmF0aW9uLmNvbnRyYWN0LlJlc3BvbnNpdmVEb25hdGlvbi5taXhlZF9kb25hdGlvbihpbnN0YW50X3JlY2lwaWVudDogYnl0ZXMsIGluc3RhbnRfYW1vdW50OiBieXRlcywgZXZlbnRfaWQ6IGJ5dGVzLCByZWNpcGllbnRfeWVzOiBieXRlcywgcmVjaXBpZW50X25vOiBieXRlcywgcGF5bWVudDogdWludDY0KSAtPiBieXRlczoKbWl4ZWRfZG9uYXRpb246CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyMjQtMjMzCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBtaXhlZF9kb25hdGlvbigKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGluc3RhbnRfcmVjaXBpZW50OiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgaW5zdGFudF9hbW91bnQ6IGFyYzQuVUludDY0LAogICAgLy8gICAgIGV2ZW50X2lkOiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICByZWNpcGllbnRfeWVzOiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgcmVjaXBpZW50X25vOiBhcmM0LkFkZHJlc3MsCiAgICAvLyAgICAgcGF5bWVudDogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24KICAgIC8vICkgLT4gYXJjNC5VSW50NjQ6CiAgICBwcm90byA2IDEKICAgIGludGNfMCAvLyAwCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI0OS0yNTAKICAgIC8vICMgVmFsaWRhdGUgdGhlIHBheW1lbnQgdHJhbnNhY3Rpb24KICAgIC8vIGFzc2VydCBwYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsICJQYXltZW50IG11c3QgYmUgc2VudCB0byBjb250cmFjdCIKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFBheW1lbnQgbXVzdCBiZSBzZW50IHRvIGNvbnRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNTEKICAgIC8vIGFzc2VydCBwYXltZW50LnNlbmRlciA9PSBUeG4uc2VuZGVyLCAiUGF5bWVudCBzZW5kZXIgbXVzdCBtYXRjaCB0cmFuc2FjdGlvbiBzZW5kZXIiCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgPT0KICAgIGFzc2VydCAvLyBQYXltZW50IHNlbmRlciBtdXN0IG1hdGNoIHRyYW5zYWN0aW9uIHNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjUyCiAgICAvLyBhc3NlcnQgcGF5bWVudC5hbW91bnQgPiAwLCAiUGF5bWVudCBhbW91bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCIKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICBkdXAKICAgIGFzc2VydCAvLyBQYXltZW50IGFtb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNTQtMjU1CiAgICAvLyAjIENhbGN1bGF0ZSB0b3RhbCByZXF1aXJlZCBhbW91bnQKICAgIC8vIGNvbmRpdGlvbmFsX2Ftb3VudCA9IGFyYzQuVUludDY0KHBheW1lbnQuYW1vdW50IC0gaW5zdGFudF9hbW91bnQubmF0aXZlKQogICAgZnJhbWVfZGlnIC01CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cDIKICAgIC0KICAgIGl0b2IKICAgIGR1cAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjU2CiAgICAvLyBhc3NlcnQgY29uZGl0aW9uYWxfYW1vdW50Lm5hdGl2ZSA+IDAsICJDb25kaXRpb25hbCBhbW91bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCIKICAgIGJ0b2kKICAgIGR1cAogICAgYXNzZXJ0IC8vIENvbmRpdGlvbmFsIGFtb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNTgKICAgIC8vIHRvdGFsX3JlcXVpcmVkID0gaW5zdGFudF9hbW91bnQubmF0aXZlICsgY29uZGl0aW9uYWxfYW1vdW50Lm5hdGl2ZQogICAgZGlnIDEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI1OQogICAgLy8gYXNzZXJ0IHBheW1lbnQuYW1vdW50ID09IHRvdGFsX3JlcXVpcmVkLCAiUGF5bWVudCBhbW91bnQgbXVzdCBlcXVhbCBzdW0gb2YgZG9uYXRpb25zIgogICAgdW5jb3ZlciAyCiAgICA9PQogICAgYXNzZXJ0IC8vIFBheW1lbnQgYW1vdW50IG11c3QgZXF1YWwgc3VtIG9mIGRvbmF0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjYxLTI2MgogICAgLy8gIyBQcm9jZXNzIGluc3RhbnQgZG9uYXRpb24gaWYgc3BlY2lmaWVkCiAgICAvLyBpZiBpbnN0YW50X2Ftb3VudC5uYXRpdmUgPiAwOgogICAgYnogbWl4ZWRfZG9uYXRpb25fYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNjMtMjY3CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgYW1vdW50PWluc3RhbnRfYW1vdW50Lm5hdGl2ZSwKICAgIC8vICAgICByZWNlaXZlcj1pbnN0YW50X3JlY2lwaWVudC5uYXRpdmUsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTYKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGZyYW1lX2RpZyAyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjYzCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNjYKICAgIC8vIGZlZT0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNjMtMjY3CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgYW1vdW50PWluc3RhbnRfYW1vdW50Lm5hdGl2ZSwKICAgIC8vICAgICByZWNlaXZlcj1pbnN0YW50X3JlY2lwaWVudC5uYXRpdmUsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAoKbWl4ZWRfZG9uYXRpb25fYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjY5LTI3MAogICAgLy8gIyBWYWxpZGF0ZSBldmVudCBleGlzdHMgYW5kIGlzIHBlbmRpbmcgZm9yIGNvbmRpdGlvbmFsIGRvbmF0aW9uCiAgICAvLyBhc3NlcnQgZXZlbnRfaWQgaW4gc2VsZi5saXN0ZWRfZXZlbnRzLCAiRXZlbnQgZG9lcyBub3QgZXhpc3QiCiAgICBieXRlY18yIC8vICJldmVudHMiCiAgICBmcmFtZV9kaWcgLTQKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBFdmVudCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjcxCiAgICAvLyBldmVudF9zdHJ1Y3QgPSBzZWxmLmxpc3RlZF9ldmVudHNbZXZlbnRfaWRdLmNvcHkoKQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubGlzdGVkX2V2ZW50cyBlbnRyeSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI3MgogICAgLy8gYXNzZXJ0IGV2ZW50X3N0cnVjdC5wZW5kaW5nLm5hdGl2ZSwgIkV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQiCiAgICBpbnRjXzIgLy8gODAKICAgIGdldGJpdAogICAgYnl0ZWNfMCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGFzc2VydCAvLyBFdmVudCBoYXMgYWxyZWFkeSBiZWVuIHJlc29sdmVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNzQtMjc1CiAgICAvLyAjIENyZWF0ZSBjb25kaXRpb25hbCBjbGF1c2Ugd2l0aCB1bmlxdWUgSUQKICAgIC8vIHNlbmRlcl9oYXNoID0gb3Auc2hhMjU2KFR4bi5zZW5kZXIuYnl0ZXMpCiAgICB0eG4gU2VuZGVyCiAgICBzaGEyNTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI3NgogICAgLy8gY2xhdXNlX2lkID0gYXJjNC5VSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgKyBvcC5idG9pKHNlbmRlcl9oYXNoWzo4XSkgKyAxKQogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgc3dhcAogICAgc3Vic3RyaW5nIDAgOAogICAgYnRvaQogICAgKwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGl0b2IKICAgIGR1cAogICAgZnJhbWVfYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyODQKICAgIC8vIGRvbm9yX2FkZHJlc3M9YXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6Mjc4LTI4NgogICAgLy8gc2VsZi5jb25kaXRpb25hbF9jbGF1c2VzW2NsYXVzZV9pZF0gPSBDb25kaXRpb25hbENsYXVzZVN0cnVjdCgKICAgIC8vICAgICBjbGF1c2VfaWQ9Y2xhdXNlX2lkLAogICAgLy8gICAgIGV2ZW50X2lkPWV2ZW50X2lkLAogICAgLy8gICAgIHBheW91dF9hbW91bnQ9Y29uZGl0aW9uYWxfYW1vdW50LAogICAgLy8gICAgIHJlY2lwaWVudF95ZXM9cmVjaXBpZW50X3llcywKICAgIC8vICAgICByZWNpcGllbnRfbm89cmVjaXBpZW50X25vLAogICAgLy8gICAgIGRvbm9yX2FkZHJlc3M9YXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIGV4ZWN1dGVkPWFyYzQuQm9vbChGYWxzZSkKICAgIC8vICkKICAgIGRpZyAxCiAgICBmcmFtZV9kaWcgLTQKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIDMKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0zCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI4NQogICAgLy8gZXhlY3V0ZWQ9YXJjNC5Cb29sKEZhbHNlKQogICAgYnl0ZWNfMCAvLyAweDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNzgtMjg2CiAgICAvLyBzZWxmLmNvbmRpdGlvbmFsX2NsYXVzZXNbY2xhdXNlX2lkXSA9IENvbmRpdGlvbmFsQ2xhdXNlU3RydWN0KAogICAgLy8gICAgIGNsYXVzZV9pZD1jbGF1c2VfaWQsCiAgICAvLyAgICAgZXZlbnRfaWQ9ZXZlbnRfaWQsCiAgICAvLyAgICAgcGF5b3V0X2Ftb3VudD1jb25kaXRpb25hbF9hbW91bnQsCiAgICAvLyAgICAgcmVjaXBpZW50X3llcz1yZWNpcGllbnRfeWVzLAogICAgLy8gICAgIHJlY2lwaWVudF9ubz1yZWNpcGllbnRfbm8sCiAgICAvLyAgICAgZG9ub3JfYWRkcmVzcz1hcmM0LkFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgICAgZXhlY3V0ZWQ9YXJjNC5Cb29sKEZhbHNlKQogICAgLy8gKQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNzgKICAgIC8vIHNlbGYuY29uZGl0aW9uYWxfY2xhdXNlc1tjbGF1c2VfaWRdID0gQ29uZGl0aW9uYWxDbGF1c2VTdHJ1Y3QoCiAgICBieXRlY18zIC8vICJjbGF1c2VzIgogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI3OC0yODYKICAgIC8vIHNlbGYuY29uZGl0aW9uYWxfY2xhdXNlc1tjbGF1c2VfaWRdID0gQ29uZGl0aW9uYWxDbGF1c2VTdHJ1Y3QoCiAgICAvLyAgICAgY2xhdXNlX2lkPWNsYXVzZV9pZCwKICAgIC8vICAgICBldmVudF9pZD1ldmVudF9pZCwKICAgIC8vICAgICBwYXlvdXRfYW1vdW50PWNvbmRpdGlvbmFsX2Ftb3VudCwKICAgIC8vICAgICByZWNpcGllbnRfeWVzPXJlY2lwaWVudF95ZXMsCiAgICAvLyAgICAgcmVjaXBpZW50X25vPXJlY2lwaWVudF9ubywKICAgIC8vICAgICBkb25vcl9hZGRyZXNzPWFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICBleGVjdXRlZD1hcmM0LkJvb2woRmFsc2UpCiAgICAvLyApCiAgICBzd2FwCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyODgtMjg5CiAgICAvLyAjIEFkZCBjbGF1c2UgdG8gZXZlbnQgaW5kZXggZm9yIGVmZmljaWVudCBsb29rdXAKICAgIC8vIGlmIGV2ZW50X2lkIGluIHNlbGYuZXZlbnRfY2xhdXNlczoKICAgIGJ5dGVjIDQgLy8gImV2ZW50X2NsYXVzZXMiCiAgICBmcmFtZV9kaWcgLTQKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogbWl4ZWRfZG9uYXRpb25fZWxzZV9ib2R5QDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI5MAogICAgLy8gZXhpc3RpbmdfY2xhdXNlcyA9IHNlbGYuZXZlbnRfY2xhdXNlc1tldmVudF9pZF0uY29weSgpCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ldmVudF9jbGF1c2VzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjkxCiAgICAvLyBleGlzdGluZ19jbGF1c2VzLmFwcGVuZChjbGF1c2VfaWQpCiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIDEKICAgIGNvbmNhdAogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgOCAvLyA4CiAgICAvCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyOTIKICAgIC8vIHNlbGYuZXZlbnRfY2xhdXNlc1tldmVudF9pZF0gPSBleGlzdGluZ19jbGF1c2VzLmNvcHkoKQogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgYm94X3B1dAoKbWl4ZWRfZG9uYXRpb25fYWZ0ZXJfaWZfZWxzZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6Mjk4CiAgICAvLyByZXR1cm4gY2xhdXNlX2lkCiAgICBmcmFtZV9kaWcgMQogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCm1peGVkX2RvbmF0aW9uX2Vsc2VfYm9keUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6Mjk0LTI5NQogICAgLy8gIyBDcmVhdGUgbmV3IGFycmF5IHdpdGggdGhpcyBjbGF1c2UKICAgIC8vIG5ld19jbGF1c2VfYXJyYXkgPSBhcmM0LkR5bmFtaWNBcnJheVthcmM0LlVJbnQ2NF0oY2xhdXNlX2lkKQogICAgYnl0ZWMgNSAvLyAweDAwMDEKICAgIGZyYW1lX2RpZyAxCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI5NgogICAgLy8gc2VsZi5ldmVudF9jbGF1c2VzW2V2ZW50X2lkXSA9IG5ld19jbGF1c2VfYXJyYXkuY29weSgpCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIGIgbWl4ZWRfZG9uYXRpb25fYWZ0ZXJfaWZfZWxzZUA2CgoKLy8gc21hcnRfY29udHJhY3RzLnJlc3BvbnNpdmVfZG9uYXRpb24uY29udHJhY3QuUmVzcG9uc2l2ZURvbmF0aW9uLnJlc29sdmVfZXZlbnQoZXZlbnRfaWQ6IGJ5dGVzLCByZXNvbHV0aW9uOiBieXRlcykgLT4gdWludDY0OgpyZXNvbHZlX2V2ZW50OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MzAwLTMwNQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgcmVzb2x2ZV9ldmVudCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGV2ZW50X2lkOiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICByZXNvbHV0aW9uOiBhcmM0LkJvb2wKICAgIC8vICkgLT4gYm9vbDoKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MzE2LTMxNwogICAgLy8gIyBFbnN1cmUgdGhlIGV2ZW50IGV4aXN0cwogICAgLy8gYXNzZXJ0IGV2ZW50X2lkIGluIHNlbGYubGlzdGVkX2V2ZW50cywgIkV2ZW50IGRvZXMgbm90IGV4aXN0IgogICAgYnl0ZWNfMiAvLyAiZXZlbnRzIgogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gRXZlbnQgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjMxOQogICAgLy8gZXZlbnRfc3RydWN0ID0gc2VsZi5saXN0ZWRfZXZlbnRzW2V2ZW50X2lkXS5jb3B5KCkKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubGlzdGVkX2V2ZW50cyBlbnRyeSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjMyMS0zMjIKICAgIC8vICMgRW5zdXJlIHRoZSBldmVudCBpcyBzdGlsbCBwZW5kaW5nCiAgICAvLyBhc3NlcnQgZXZlbnRfc3RydWN0LnBlbmRpbmcubmF0aXZlLCAiRXZlbnQgaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZCIKICAgIGR1cAogICAgaW50Y18yIC8vIDgwCiAgICBnZXRiaXQKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBhc3NlcnQgLy8gRXZlbnQgaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MzI0LTMyNQogICAgLy8gIyBFbnN1cmUgdGhlIGNhbGxlciBpcyB0aGUgYXV0aG9yaXplZCBvcmFjbGUKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IGV2ZW50X3N0cnVjdC5vcmFjbGVfYWRkcmVzcy5uYXRpdmUsICJPbmx5IGF1dGhvcml6ZWQgb3JhY2xlIGNhbiByZXNvbHZlIGV2ZW50IgogICAgdHhuIFNlbmRlcgogICAgZGlnIDEKICAgIGV4dHJhY3QgMTEgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgYXV0aG9yaXplZCBvcmFjbGUgY2FuIHJlc29sdmUgZXZlbnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjMyNy0zMjgKICAgIC8vICMgVXBkYXRlIHRoZSBldmVudCBzdHJ1Y3QKICAgIC8vIGV2ZW50X3N0cnVjdC5wZW5kaW5nID0gYXJjNC5Cb29sKEZhbHNlKQogICAgaW50Y18yIC8vIDgwCiAgICBpbnRjXzAgLy8gMAogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTozMjkKICAgIC8vIGV2ZW50X3N0cnVjdC5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbgogICAgZnJhbWVfZGlnIC0xCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBpbnRjXzMgLy8gODEKICAgIHN3YXAKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MzMwCiAgICAvLyBzZWxmLmxpc3RlZF9ldmVudHNbZXZlbnRfaWRdID0gZXZlbnRfc3RydWN0LmNvcHkoKQogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MzMyCiAgICAvLyByZXR1cm4gVHJ1ZQogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5yZXNwb25zaXZlX2RvbmF0aW9uLmNvbnRyYWN0LlJlc3BvbnNpdmVEb25hdGlvbi5leGVjdXRlX2NvbmRpdGlvbmFsX2NsYXVzZShjbGF1c2VfaWQ6IGJ5dGVzKSAtPiB1aW50NjQ6CmV4ZWN1dGVfY29uZGl0aW9uYWxfY2xhdXNlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MzM0LTMzOAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgZXhlY3V0ZV9jb25kaXRpb25hbF9jbGF1c2UoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBjbGF1c2VfaWQ6IGFyYzQuVUludDY0CiAgICAvLyApIC0+IGJvb2w6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjM0OS0zNTAKICAgIC8vICMgRW5zdXJlIHRoZSBjbGF1c2UgZXhpc3RzCiAgICAvLyBhc3NlcnQgY2xhdXNlX2lkIGluIHNlbGYuY29uZGl0aW9uYWxfY2xhdXNlcywgIkNsYXVzZSBkb2VzIG5vdCBleGlzdCIKICAgIGJ5dGVjXzMgLy8gImNsYXVzZXMiCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgZHVwbiAyCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBDbGF1c2UgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjM1MgogICAgLy8gY2xhdXNlX3N0cnVjdCA9IHNlbGYuY29uZGl0aW9uYWxfY2xhdXNlc1tjbGF1c2VfaWRdLmNvcHkoKQogICAgYm94X2dldAogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbmRpdGlvbmFsX2NsYXVzZXMgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTozNTQtMzU1CiAgICAvLyAjIEVuc3VyZSB0aGUgY2xhdXNlIGhhc24ndCBiZWVuIGV4ZWN1dGVkIHlldAogICAgLy8gYXNzZXJ0IG5vdCBjbGF1c2Vfc3RydWN0LmV4ZWN1dGVkLm5hdGl2ZSwgIkNsYXVzZSBoYXMgYWxyZWFkeSBiZWVuIGV4ZWN1dGVkIgogICAgZHVwCiAgICBpbnRjIDQgLy8gOTYwCiAgICBnZXRiaXQKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICAhCiAgICBhc3NlcnQgLy8gQ2xhdXNlIGhhcyBhbHJlYWR5IGJlZW4gZXhlY3V0ZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjM1Ny0zNTgKICAgIC8vICMgR2V0IHRoZSBhc3NvY2lhdGVkIGV2ZW50CiAgICAvLyBhc3NlcnQgY2xhdXNlX3N0cnVjdC5ldmVudF9pZCBpbiBzZWxmLmxpc3RlZF9ldmVudHMsICJBc3NvY2lhdGVkIGV2ZW50IGRvZXMgbm90IGV4aXN0IgogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBieXRlY18yIC8vICJldmVudHMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gQXNzb2NpYXRlZCBldmVudCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MzU5CiAgICAvLyBldmVudF9zdHJ1Y3QgPSBzZWxmLmxpc3RlZF9ldmVudHNbY2xhdXNlX3N0cnVjdC5ldmVudF9pZF0uY29weSgpCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5saXN0ZWRfZXZlbnRzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MzYxLTM2MgogICAgLy8gIyBFbnN1cmUgdGhlIGV2ZW50IGhhcyBiZWVuIHJlc29sdmVkCiAgICAvLyBhc3NlcnQgbm90IGV2ZW50X3N0cnVjdC5wZW5kaW5nLm5hdGl2ZSwgIkV2ZW50IGhhcyBub3QgYmVlbiByZXNvbHZlZCB5ZXQiCiAgICBkdXAKICAgIGludGNfMiAvLyA4MAogICAgZ2V0Yml0CiAgICBieXRlY18wIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgIQogICAgYXNzZXJ0IC8vIEV2ZW50IGhhcyBub3QgYmVlbiByZXNvbHZlZCB5ZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjM2NC0zNjUKICAgIC8vICMgRGV0ZXJtaW5lIHJlY2lwaWVudCBiYXNlZCBvbiBldmVudCByZXNvbHV0aW9uCiAgICAvLyBpZiBldmVudF9zdHJ1Y3QucmVzb2x1dGlvbi5uYXRpdmU6CiAgICBpbnRjXzMgLy8gODEKICAgIGdldGJpdAogICAgYnl0ZWNfMCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGJ6IGV4ZWN1dGVfY29uZGl0aW9uYWxfY2xhdXNlX2Vsc2VfYm9keUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTozNjYKICAgIC8vIHJlY2lwaWVudCA9IGNsYXVzZV9zdHJ1Y3QucmVjaXBpZW50X3llcy5uYXRpdmUKICAgIGZyYW1lX2RpZyAxCiAgICBleHRyYWN0IDI0IDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwoKZXhlY3V0ZV9jb25kaXRpb25hbF9jbGF1c2VfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MzcwLTM3NQogICAgLy8gIyBFeGVjdXRlIHRoZSBwYXlvdXQKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICBhbW91bnQ9Y2xhdXNlX3N0cnVjdC5wYXlvdXRfYW1vdW50Lm5hdGl2ZSwKICAgIC8vICAgICByZWNlaXZlcj1yZWNpcGllbnQsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTozNzIKICAgIC8vIGFtb3VudD1jbGF1c2Vfc3RydWN0LnBheW91dF9hbW91bnQubmF0aXZlLAogICAgZnJhbWVfZGlnIDEKICAgIGR1cAogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjM3MC0zNzEKICAgIC8vICMgRXhlY3V0ZSB0aGUgcGF5b3V0CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTozNzQKICAgIC8vIGZlZT0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTozNzAtMzc1CiAgICAvLyAjIEV4ZWN1dGUgdGhlIHBheW91dAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIGFtb3VudD1jbGF1c2Vfc3RydWN0LnBheW91dF9hbW91bnQubmF0aXZlLAogICAgLy8gICAgIHJlY2VpdmVyPXJlY2lwaWVudCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTozNzctMzc4CiAgICAvLyAjIE1hcmsgdGhlIGNsYXVzZSBhcyBleGVjdXRlZAogICAgLy8gY2xhdXNlX3N0cnVjdC5leGVjdXRlZCA9IGFyYzQuQm9vbChUcnVlKQogICAgaW50YyA0IC8vIDk2MAogICAgaW50Y18xIC8vIDEKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6Mzc5CiAgICAvLyBzZWxmLmNvbmRpdGlvbmFsX2NsYXVzZXNbY2xhdXNlX2lkXSA9IGNsYXVzZV9zdHJ1Y3QuY29weSgpCiAgICBmcmFtZV9kaWcgMAogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MzgxCiAgICAvLyByZXR1cm4gVHJ1ZQogICAgaW50Y18xIC8vIDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpleGVjdXRlX2NvbmRpdGlvbmFsX2NsYXVzZV9lbHNlX2JvZHlAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjM2OAogICAgLy8gcmVjaXBpZW50ID0gY2xhdXNlX3N0cnVjdC5yZWNpcGllbnRfbm8ubmF0aXZlCiAgICBmcmFtZV9kaWcgMQogICAgZXh0cmFjdCA1NiAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGIgZXhlY3V0ZV9jb25kaXRpb25hbF9jbGF1c2VfYWZ0ZXJfaWZfZWxzZUAzCgoKLy8gc21hcnRfY29udHJhY3RzLnJlc3BvbnNpdmVfZG9uYXRpb24uY29udHJhY3QuUmVzcG9uc2l2ZURvbmF0aW9uLmV4ZWN1dGVfY2xhdXNlc19mb3JfZXZlbnQoZXZlbnRfaWQ6IGJ5dGVzKSAtPiBieXRlczoKZXhlY3V0ZV9jbGF1c2VzX2Zvcl9ldmVudDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjM4My0zODcKICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gZGVmIGV4ZWN1dGVfY2xhdXNlc19mb3JfZXZlbnQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBldmVudF9pZDogYXJjNC5VSW50NjQKICAgIC8vICkgLT4gYXJjNC5VSW50NjQ6CiAgICBwcm90byAxIDEKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDQKICAgIHB1c2hieXRlcyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTozOTgtMzk5CiAgICAvLyAjIEVuc3VyZSB0aGUgZXZlbnQgZXhpc3RzIGFuZCBpcyByZXNvbHZlZAogICAgLy8gYXNzZXJ0IGV2ZW50X2lkIGluIHNlbGYubGlzdGVkX2V2ZW50cywgIkV2ZW50IGRvZXMgbm90IGV4aXN0IgogICAgYnl0ZWNfMiAvLyAiZXZlbnRzIgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gRXZlbnQgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjQwMAogICAgLy8gZXZlbnRfc3RydWN0ID0gc2VsZi5saXN0ZWRfZXZlbnRzW2V2ZW50X2lkXS5jb3B5KCkKICAgIGJveF9nZXQKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5saXN0ZWRfZXZlbnRzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDAxCiAgICAvLyBhc3NlcnQgbm90IGV2ZW50X3N0cnVjdC5wZW5kaW5nLm5hdGl2ZSwgIkV2ZW50IGhhcyBub3QgYmVlbiByZXNvbHZlZCB5ZXQiCiAgICBpbnRjXzIgLy8gODAKICAgIGdldGJpdAogICAgYnl0ZWNfMCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgICEKICAgIGFzc2VydCAvLyBFdmVudCBoYXMgbm90IGJlZW4gcmVzb2x2ZWQgeWV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo0MDMtNDA0CiAgICAvLyAjIEdldCBhbGwgY2xhdXNlcyBmb3IgdGhpcyBldmVudAogICAgLy8gaWYgZXZlbnRfaWQgbm90IGluIHNlbGYuZXZlbnRfY2xhdXNlczoKICAgIGJ5dGVjIDQgLy8gImV2ZW50X2NsYXVzZXMiCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJueiBleGVjdXRlX2NsYXVzZXNfZm9yX2V2ZW50X2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDA1LTQwNgogICAgLy8gIyBObyBjbGF1c2VzIHRvIGV4ZWN1dGUKICAgIC8vIHJldHVybiBhcmM0LlVJbnQ2NCgwKQogICAgYnl0ZWMgNiAvLyAweDAwMDAwMDAwMDAwMDAwMDAKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpleGVjdXRlX2NsYXVzZXNfZm9yX2V2ZW50X2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjQwOAogICAgLy8gY2xhdXNlX2lkcyA9IHNlbGYuZXZlbnRfY2xhdXNlc1tldmVudF9pZF0uY29weSgpCiAgICBmcmFtZV9kaWcgOAogICAgYm94X2dldAogICAgc3dhcAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBmcmFtZV9idXJ5IDEKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmV2ZW50X2NsYXVzZXMgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo0MDkKICAgIC8vIGV4ZWN1dGVkX2NvdW50ID0gYXJjNC5VSW50NjQoMCkKICAgIGJ5dGVjIDYgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjQxMS00MTIKICAgIC8vICMgRXhlY3V0ZSBlYWNoIHVuZXhlY3V0ZWQgY2xhdXNlCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UoY2xhdXNlX2lkcy5sZW5ndGgpOgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBmcmFtZV9idXJ5IDYKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDUKCmV4ZWN1dGVfY2xhdXNlc19mb3JfZXZlbnRfZm9yX2hlYWRlckAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDExLTQxMgogICAgLy8gIyBFeGVjdXRlIGVhY2ggdW5leGVjdXRlZCBjbGF1c2UKICAgIC8vIGZvciBpIGluIHVyYW5nZShjbGF1c2VfaWRzLmxlbmd0aCk6CiAgICBmcmFtZV9kaWcgNQogICAgZnJhbWVfZGlnIDYKICAgIDwKICAgIGJ6IGV4ZWN1dGVfY2xhdXNlc19mb3JfZXZlbnRfYWZ0ZXJfZm9yQDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo0MTMKICAgIC8vIGNsYXVzZV9pZCA9IGNsYXVzZV9pZHNbaV0KICAgIGZyYW1lX2RpZyAxCiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIDUKICAgIHB1c2hpbnQgOCAvLyA4CiAgICAqCiAgICBwdXNoaW50IDggLy8gOAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo0MTUKICAgIC8vIGlmIGNsYXVzZV9pZCBpbiBzZWxmLmNvbmRpdGlvbmFsX2NsYXVzZXM6CiAgICBieXRlY18zIC8vICJjbGF1c2VzIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBmcmFtZV9kaWcgMwogICAgZnJhbWVfYnVyeSA0CiAgICBieiBleGVjdXRlX2NsYXVzZXNfZm9yX2V2ZW50X2FmdGVyX2lmX2Vsc2VAMTIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjQxNgogICAgLy8gY2xhdXNlX3N0cnVjdCA9IHNlbGYuY29uZGl0aW9uYWxfY2xhdXNlc1tjbGF1c2VfaWRdLmNvcHkoKQogICAgZnJhbWVfZGlnIDAKICAgIGJveF9nZXQKICAgIHN3YXAKICAgIGR1cAogICAgY292ZXIgMgogICAgZnJhbWVfYnVyeSAyCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jb25kaXRpb25hbF9jbGF1c2VzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDE4LTQxOQogICAgLy8gIyBTa2lwIGlmIGFscmVhZHkgZXhlY3V0ZWQKICAgIC8vIGlmIGNsYXVzZV9zdHJ1Y3QuZXhlY3V0ZWQubmF0aXZlOgogICAgaW50YyA0IC8vIDk2MAogICAgZ2V0Yml0CiAgICBieXRlY18wIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgYm56IGV4ZWN1dGVfY2xhdXNlc19mb3JfZXZlbnRfZm9yX2Zvb3RlckAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDIyLTQyMwogICAgLy8gIyBEZXRlcm1pbmUgcmVjaXBpZW50IGJhc2VkIG9uIGV2ZW50IHJlc29sdXRpb24KICAgIC8vIGlmIGV2ZW50X3N0cnVjdC5yZXNvbHV0aW9uLm5hdGl2ZToKICAgIGZyYW1lX2RpZyA3CiAgICBpbnRjXzMgLy8gODEKICAgIGdldGJpdAogICAgYnl0ZWNfMCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGJ6IGV4ZWN1dGVfY2xhdXNlc19mb3JfZXZlbnRfZWxzZV9ib2R5QDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjQyNAogICAgLy8gcmVjaXBpZW50ID0gY2xhdXNlX3N0cnVjdC5yZWNpcGllbnRfeWVzLm5hdGl2ZQogICAgZnJhbWVfZGlnIDIKICAgIGV4dHJhY3QgMjQgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCgpleGVjdXRlX2NsYXVzZXNfZm9yX2V2ZW50X2FmdGVyX2lmX2Vsc2VAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo0MjgtNDMzCiAgICAvLyAjIEV4ZWN1dGUgdGhlIHBheW91dAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIGFtb3VudD1jbGF1c2Vfc3RydWN0LnBheW91dF9hbW91bnQubmF0aXZlLAogICAgLy8gICAgIHJlY2VpdmVyPXJlY2lwaWVudCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjQzMAogICAgLy8gYW1vdW50PWNsYXVzZV9zdHJ1Y3QucGF5b3V0X2Ftb3VudC5uYXRpdmUsCiAgICBmcmFtZV9kaWcgMgogICAgZHVwCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDI4LTQyOQogICAgLy8gIyBFeGVjdXRlIHRoZSBwYXlvdXQKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjQzMgogICAgLy8gZmVlPTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjQyOC00MzMKICAgIC8vICMgRXhlY3V0ZSB0aGUgcGF5b3V0CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgYW1vdW50PWNsYXVzZV9zdHJ1Y3QucGF5b3V0X2Ftb3VudC5uYXRpdmUsCiAgICAvLyAgICAgcmVjZWl2ZXI9cmVjaXBpZW50LAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjQzNS00MzYKICAgIC8vICMgTWFyayB0aGUgY2xhdXNlIGFzIGV4ZWN1dGVkCiAgICAvLyBjbGF1c2Vfc3RydWN0LmV4ZWN1dGVkID0gYXJjNC5Cb29sKFRydWUpCiAgICBpbnRjIDQgLy8gOTYwCiAgICBpbnRjXzEgLy8gMQogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo0MzcKICAgIC8vIHNlbGYuY29uZGl0aW9uYWxfY2xhdXNlc1tjbGF1c2VfaWRdID0gY2xhdXNlX3N0cnVjdC5jb3B5KCkKICAgIGZyYW1lX2RpZyAwCiAgICBzd2FwCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo0MzgKICAgIC8vIGV4ZWN1dGVkX2NvdW50ID0gYXJjNC5VSW50NjQoZXhlY3V0ZWRfY291bnQubmF0aXZlICsgMSkKICAgIGZyYW1lX2RpZyAzCiAgICBidG9pCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgaXRvYgogICAgZnJhbWVfYnVyeSA0CgpleGVjdXRlX2NsYXVzZXNfZm9yX2V2ZW50X2FmdGVyX2lmX2Vsc2VAMTI6CiAgICBmcmFtZV9kaWcgNAogICAgZnJhbWVfYnVyeSAzCgpleGVjdXRlX2NsYXVzZXNfZm9yX2V2ZW50X2Zvcl9mb290ZXJAMTM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo0MTEtNDEyCiAgICAvLyAjIEV4ZWN1dGUgZWFjaCB1bmV4ZWN1dGVkIGNsYXVzZQogICAgLy8gZm9yIGkgaW4gdXJhbmdlKGNsYXVzZV9pZHMubGVuZ3RoKToKICAgIGZyYW1lX2RpZyA1CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSA1CiAgICBiIGV4ZWN1dGVfY2xhdXNlc19mb3JfZXZlbnRfZm9yX2hlYWRlckAzCgpleGVjdXRlX2NsYXVzZXNfZm9yX2V2ZW50X2Vsc2VfYm9keUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDI2CiAgICAvLyByZWNpcGllbnQgPSBjbGF1c2Vfc3RydWN0LnJlY2lwaWVudF9uby5uYXRpdmUKICAgIGZyYW1lX2RpZyAyCiAgICBleHRyYWN0IDU2IDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYiBleGVjdXRlX2NsYXVzZXNfZm9yX2V2ZW50X2FmdGVyX2lmX2Vsc2VAMTAKCmV4ZWN1dGVfY2xhdXNlc19mb3JfZXZlbnRfYWZ0ZXJfZm9yQDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDQwCiAgICAvLyByZXR1cm4gZXhlY3V0ZWRfY291bnQKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5yZXNwb25zaXZlX2RvbmF0aW9uLmNvbnRyYWN0LlJlc3BvbnNpdmVEb25hdGlvbi5nZXRfZXZlbnRfaW5mbyhldmVudF9pZDogYnl0ZXMpIC0+IGJ5dGVzOgpnZXRfZXZlbnRfaW5mbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjQ0Mi00NDYKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBnZXRfZXZlbnRfaW5mbygKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGV2ZW50X2lkOiBhcmM0LlVJbnQ2NAogICAgLy8gKSAtPiBFdmVudFN0cnVjdDoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDU2CiAgICAvLyBhc3NlcnQgZXZlbnRfaWQgaW4gc2VsZi5saXN0ZWRfZXZlbnRzLCAiRXZlbnQgZG9lcyBub3QgZXhpc3QiCiAgICBieXRlY18yIC8vICJldmVudHMiCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBFdmVudCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDU3CiAgICAvLyByZXR1cm4gc2VsZi5saXN0ZWRfZXZlbnRzW2V2ZW50X2lkXQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubGlzdGVkX2V2ZW50cyBlbnRyeSBleGlzdHMKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5yZXNwb25zaXZlX2RvbmF0aW9uLmNvbnRyYWN0LlJlc3BvbnNpdmVEb25hdGlvbi5nZXRfY2xhdXNlX2luZm8oY2xhdXNlX2lkOiBieXRlcykgLT4gYnl0ZXM6CmdldF9jbGF1c2VfaW5mbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjQ1OS00NjMKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBnZXRfY2xhdXNlX2luZm8oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBjbGF1c2VfaWQ6IGFyYzQuVUludDY0CiAgICAvLyApIC0+IENvbmRpdGlvbmFsQ2xhdXNlU3RydWN0OgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo0NzMKICAgIC8vIGFzc2VydCBjbGF1c2VfaWQgaW4gc2VsZi5jb25kaXRpb25hbF9jbGF1c2VzLCAiQ2xhdXNlIGRvZXMgbm90IGV4aXN0IgogICAgYnl0ZWNfMyAvLyAiY2xhdXNlcyIKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIENsYXVzZSBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NDc0CiAgICAvLyByZXR1cm4gc2VsZi5jb25kaXRpb25hbF9jbGF1c2VzW2NsYXVzZV9pZF0KICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbmRpdGlvbmFsX2NsYXVzZXMgZW50cnkgZXhpc3RzCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMucmVzcG9uc2l2ZV9kb25hdGlvbi5jb250cmFjdC5SZXNwb25zaXZlRG9uYXRpb24uZ2V0X2NsYXVzZXNfZm9yX2V2ZW50KGV2ZW50X2lkOiBieXRlcykgLT4gYnl0ZXM6CmdldF9jbGF1c2VzX2Zvcl9ldmVudDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjQ5NC00OTgKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBnZXRfY2xhdXNlc19mb3JfZXZlbnQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBldmVudF9pZDogYXJjNC5VSW50NjQKICAgIC8vICkgLT4gYXJjNC5EeW5hbWljQXJyYXlbYXJjNC5VSW50NjRdOgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo1MDktNTEwCiAgICAvLyAjIFJldHVybiBpbmRleGVkIGNsYXVzZXMgZm9yIHRoaXMgZXZlbnQKICAgIC8vIGlmIGV2ZW50X2lkIGluIHNlbGYuZXZlbnRfY2xhdXNlczoKICAgIGJ5dGVjIDQgLy8gImV2ZW50X2NsYXVzZXMiCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJ6IGdldF9jbGF1c2VzX2Zvcl9ldmVudF9lbHNlX2JvZHlAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NTExCiAgICAvLyByZXR1cm4gc2VsZi5ldmVudF9jbGF1c2VzW2V2ZW50X2lkXS5jb3B5KCkKICAgIGZyYW1lX2RpZyAwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ldmVudF9jbGF1c2VzIGVudHJ5IGV4aXN0cwogICAgc3dhcAogICAgcmV0c3ViCgpnZXRfY2xhdXNlc19mb3JfZXZlbnRfZWxzZV9ib2R5QDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo1MTMtNTE0CiAgICAvLyAjIE5vIGNsYXVzZXMgZm9yIHRoaXMgZXZlbnQKICAgIC8vIHJldHVybiBhcmM0LkR5bmFtaWNBcnJheVthcmM0LlVJbnQ2NF0oKQogICAgcHVzaGJ5dGVzIDB4MDAwMAogICAgc3dhcAogICAgcmV0c3ViCg==","clear":"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"},"byteCode":{"approval":"CiAFAAFQUcAHJgcBAAQVH3x1BmV2ZW50cwdjbGF1c2VzDWV2ZW50X2NsYXVzZXMCAAEIAAAAAAAAAAAxG0EBa4ILBJY+ku8EhI2+UgQSBtj9BKb+00QELbaZRgS1oWfKBBU6UlwEuE4V1gR2Xg8/BMid2QIELB1tFzYaAI4LAQEA3wC8AJMAeABgAE0AOgAnABUAAiJDMRkURDEYRDYaAYgETSlMULAjQzEZFEQxGESABhUffHUAALAjQzEZFEQxGEQ2GgGIBBkpTFCwI0MxGRREMRhENhoBiAP3KUxQsCNDMRkURDEYRDYaAYgDDilMULAjQzEZFEQxGEQ2GgGIAokoIk8CVClMULAjQzEZFEQxGEQ2GgE2GgKIAjooIk8CVClMULAjQzEZFEQxGEQ2GgE2GgI2GgM2GgQ2GgUxFiMJSTgQIxJEiAFLKUxQsCNDMRkURDEYRDYaATYaAjYaAzEWIwlJOBAjEkSIAJspTFCwI0MxGRREMRhENhoBMRYjCUk4ECMSRIgATygiTwJUKUxQsCNDMRkURDEYRDYaATYaAogAESlMULAjQzEZQP7kMRgURCNDigIBMgcWSYACACtQgAGAUCUiVIv/UIv+UCpLAlBJvEhMv4mKAgGL/zgHMgoSRIv/OAAxABJEi/84CElESYHoBw9EsYv+sgeyCCOyECKyAbMjiYoEASqL/FBJvUUBRL5EJFMoIk8CVCJTRIv/OAcyChJEi/84ADEAEkSL/zgISUQxAAEyB0xRAAgXCBZJTwIWMQBLAov8UE8CUIv9UIv+UExQKFArTwJQTL8nBIv8UEm9RQFBAByLAUm+RFcCAIsAUEkVgQgKFlcGAkxQSwG8SL+JJwWLAFCLAUm8SEy/iYoGASJJi/84BzIKEkSL/zgAMQASRIv/OAhJRIv7F0lOAkoJFklOAxdJREsBCE8CEkRBABCxi/qyB4sCsggjshAisgGzKov8UEm9RQFEvkQkUygiTwJUIlNEMQABMgdMUQAIFwgjCBZJjAExAEsBi/xQiwNQi/1Qi/5QTFAoUCtPAlBMvycEi/xQSYwAvUUBQQAgiwBJvkRXAgCLAVBJFYEIChZXBgJMUEsBvEi/iwGMAIknBYsBUIsASbxITL9C/+yKAgEqi/5QSb1FAURJvkRJJFMoIk8CVCJTRDEASwFXCyASRCQiVIv/IlMlTFRLAbxIvyOJigEBK4v/UEcCvUUBRL5MSU8CREkhBFMoIk8CVCJTFERXCAgqTFBJvUUBRL5ESSRTKCJPAlQiUxREJVMoIk8CVCJTQQAliwFXGCCxiwFJgRBbTwKyB7III7IQIrIBsyEEI1SLAEy/I4wAiYsBVzggQv/YigEBIkcEgABJKov/UEm9RQFEvkxJTwJEJFMoIk8CVCJTFEQnBIv/UEm9RQFAAAUnBowAiYsIvkxJTgKMAUQnBowDIlmMBiKMBYsFiwYMQQCAiwFXAgCLBYEIC4EIWCtMUEmMAL1FAYsDjARBAE6LAL5MSU4CjAJEIQRTKCJPAlQiU0AAO4sHJVMoIk8CVCJTQQA2iwJXGCCxiwJJgRBbTwKyB7III7IQIrIBsyEEI1SLAEy/iwMXIwgWjASLBIwDiwUjCIwFQv+AiwJXOCBC/8eLA4wAiYoBASqL/1BJvUUBRL5EiYoBASuL/1BJvUUBRL5EiYoBAScEi/9QSb1FAUEABosAvkRMiYACAABMiQ==","clear":"CoEBQw=="},"compilerInfo":{"compiler":"puya","compilerVersion":{"major":4,"minor":10,"patch":0}},"events":[],"templateVariables":{}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


// Type definitions for ARC-56 structs

export type ConditionalClauseStruct = {
  clauseId: bigint,
  eventId: bigint,
  payoutAmount: bigint,
  recipientYes: string,
  recipientNo: string,
  donorAddress: string,
  executed: boolean
}


/**
 * Converts the ABI tuple representation of a ConditionalClauseStruct to the struct representation
 */
export function ConditionalClauseStructFromTuple(abiTuple: [bigint, bigint, bigint, string, string, string, boolean]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.ConditionalClauseStruct, APP_SPEC.structs) as ConditionalClauseStruct
}

export type EventStruct = {
  eventId: bigint,
  eventString: string,
  pending: boolean,
  resolution: boolean,
  oracleAddress: string
}


/**
 * Converts the ABI tuple representation of a EventStruct to the struct representation
 */
export function EventStructFromTuple(abiTuple: [bigint, string, boolean, boolean, string]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.EventStruct, APP_SPEC.structs) as EventStruct
}

/**
 * The argument types for the ResponsiveDonation contract
 */
export type ResponsiveDonationArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'create_event(string,address)uint64': {
      /**
       * Description of the event (e.g., "Hurricane hits Miami")
       */
      eventString: string
      /**
       * Address authorized to resolve this event
       */
      oracleAddress: string
    }
    'instantaneous_payout(address,pay)bool': {
      /**
       * Address to receive the donation (charity/recipient)
       */
      recipientAddress: string
      /**
       * The payment transaction (must be grouped with the app call)
       */
      payment: AppMethodCallTransactionArgument
    }
    'create_conditional_donation(uint64,address,address,pay)uint64': {
      /**
       * The event this donation depends on
       */
      eventId: bigint | number
      /**
       * Address to receive funds if event resolves to true
       */
      recipientYes: string
      /**
       * Address to receive funds if event resolves to false (often donor)
       */
      recipientNo: string
      /**
       * The payment transaction (funds held in escrow)
       */
      payment: AppMethodCallTransactionArgument
    }
    'mixed_donation(address,uint64,uint64,address,address,pay)uint64': {
      /**
       * Address to receive instant donation (use zero address if no instant donation)
       */
      instantRecipient: string
      /**
       * Amount for instant donation (use 0 if no instant donation)
       */
      instantAmount: bigint | number
      /**
       * Event ID for conditional donation
       */
      eventId: bigint | number
      /**
       * Address to receive funds if event resolves to true
       */
      recipientYes: string
      /**
       * Address to receive funds if event resolves to false
       */
      recipientNo: string
      /**
       * The payment transaction covering both donations
       */
      payment: AppMethodCallTransactionArgument
    }
    'resolve_event(uint64,bool)bool': {
      /**
       * The event to resolve
       */
      eventId: bigint | number
      /**
       * The outcome of the event (true/false)
       */
      resolution: boolean
    }
    'execute_conditional_clause(uint64)bool': {
      /**
       * The clause to execute
       */
      clauseId: bigint | number
    }
    'execute_clauses_for_event(uint64)uint64': {
      /**
       * The event whose clauses should be executed
       */
      eventId: bigint | number
    }
    'get_event_info(uint64)(uint64,string,bool,bool,address)': {
      /**
       * The event ID to query
       */
      eventId: bigint | number
    }
    'get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)': {
      /**
       * The clause ID to query
       */
      clauseId: bigint | number
    }
    'get_pending_events()uint64[]': Record<string, never>
    'get_clauses_for_event(uint64)uint64[]': {
      /**
       * The event to get clauses for
       */
      eventId: bigint | number
    }
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'create_event(string,address)uint64': [eventString: string, oracleAddress: string]
    'instantaneous_payout(address,pay)bool': [recipientAddress: string, payment: AppMethodCallTransactionArgument]
    'create_conditional_donation(uint64,address,address,pay)uint64': [eventId: bigint | number, recipientYes: string, recipientNo: string, payment: AppMethodCallTransactionArgument]
    'mixed_donation(address,uint64,uint64,address,address,pay)uint64': [instantRecipient: string, instantAmount: bigint | number, eventId: bigint | number, recipientYes: string, recipientNo: string, payment: AppMethodCallTransactionArgument]
    'resolve_event(uint64,bool)bool': [eventId: bigint | number, resolution: boolean]
    'execute_conditional_clause(uint64)bool': [clauseId: bigint | number]
    'execute_clauses_for_event(uint64)uint64': [eventId: bigint | number]
    'get_event_info(uint64)(uint64,string,bool,bool,address)': [eventId: bigint | number]
    'get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)': [clauseId: bigint | number]
    'get_pending_events()uint64[]': []
    'get_clauses_for_event(uint64)uint64[]': [eventId: bigint | number]
  }
}

/**
 * The return type for each method
 */
export type ResponsiveDonationReturns = {
  'create_event(string,address)uint64': bigint
  'instantaneous_payout(address,pay)bool': boolean
  'create_conditional_donation(uint64,address,address,pay)uint64': bigint
  'mixed_donation(address,uint64,uint64,address,address,pay)uint64': bigint
  'resolve_event(uint64,bool)bool': boolean
  'execute_conditional_clause(uint64)bool': boolean
  'execute_clauses_for_event(uint64)uint64': bigint
  'get_event_info(uint64)(uint64,string,bool,bool,address)': EventStruct
  'get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)': ConditionalClauseStruct
  'get_pending_events()uint64[]': bigint[]
  'get_clauses_for_event(uint64)uint64[]': bigint[]
}

/**
 * Defines the types of available calls and state of the ResponsiveDonation smart contract.
 */
export type ResponsiveDonationTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'create_event(string,address)uint64' | 'create_event', {
      argsObj: ResponsiveDonationArgs['obj']['create_event(string,address)uint64']
      argsTuple: ResponsiveDonationArgs['tuple']['create_event(string,address)uint64']
      /**
       * The event ID of the created event (uint64)
       */
      returns: ResponsiveDonationReturns['create_event(string,address)uint64']
    }>
    & Record<'instantaneous_payout(address,pay)bool' | 'instantaneous_payout', {
      argsObj: ResponsiveDonationArgs['obj']['instantaneous_payout(address,pay)bool']
      argsTuple: ResponsiveDonationArgs['tuple']['instantaneous_payout(address,pay)bool']
      /**
       * True if the donation is successful
       */
      returns: ResponsiveDonationReturns['instantaneous_payout(address,pay)bool']
    }>
    & Record<'create_conditional_donation(uint64,address,address,pay)uint64' | 'create_conditional_donation', {
      argsObj: ResponsiveDonationArgs['obj']['create_conditional_donation(uint64,address,address,pay)uint64']
      argsTuple: ResponsiveDonationArgs['tuple']['create_conditional_donation(uint64,address,address,pay)uint64']
      /**
       * The clause ID of the created conditional donation
       */
      returns: ResponsiveDonationReturns['create_conditional_donation(uint64,address,address,pay)uint64']
    }>
    & Record<'mixed_donation(address,uint64,uint64,address,address,pay)uint64' | 'mixed_donation', {
      argsObj: ResponsiveDonationArgs['obj']['mixed_donation(address,uint64,uint64,address,address,pay)uint64']
      argsTuple: ResponsiveDonationArgs['tuple']['mixed_donation(address,uint64,uint64,address,address,pay)uint64']
      /**
       * The clause ID for the conditional donation created
       */
      returns: ResponsiveDonationReturns['mixed_donation(address,uint64,uint64,address,address,pay)uint64']
    }>
    & Record<'resolve_event(uint64,bool)bool' | 'resolve_event', {
      argsObj: ResponsiveDonationArgs['obj']['resolve_event(uint64,bool)bool']
      argsTuple: ResponsiveDonationArgs['tuple']['resolve_event(uint64,bool)bool']
      /**
       * True if the event is successfully resolved
       */
      returns: ResponsiveDonationReturns['resolve_event(uint64,bool)bool']
    }>
    & Record<'execute_conditional_clause(uint64)bool' | 'execute_conditional_clause', {
      argsObj: ResponsiveDonationArgs['obj']['execute_conditional_clause(uint64)bool']
      argsTuple: ResponsiveDonationArgs['tuple']['execute_conditional_clause(uint64)bool']
      /**
       * True if the clause is successfully executed
       */
      returns: ResponsiveDonationReturns['execute_conditional_clause(uint64)bool']
    }>
    & Record<'execute_clauses_for_event(uint64)uint64' | 'execute_clauses_for_event', {
      argsObj: ResponsiveDonationArgs['obj']['execute_clauses_for_event(uint64)uint64']
      argsTuple: ResponsiveDonationArgs['tuple']['execute_clauses_for_event(uint64)uint64']
      /**
       * Number of clauses executed
       */
      returns: ResponsiveDonationReturns['execute_clauses_for_event(uint64)uint64']
    }>
    & Record<'get_event_info(uint64)(uint64,string,bool,bool,address)' | 'get_event_info', {
      argsObj: ResponsiveDonationArgs['obj']['get_event_info(uint64)(uint64,string,bool,bool,address)']
      argsTuple: ResponsiveDonationArgs['tuple']['get_event_info(uint64)(uint64,string,bool,bool,address)']
      /**
       * The EventStruct containing the event's information
       */
      returns: ResponsiveDonationReturns['get_event_info(uint64)(uint64,string,bool,bool,address)']
    }>
    & Record<'get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)' | 'get_clause_info', {
      argsObj: ResponsiveDonationArgs['obj']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)']
      argsTuple: ResponsiveDonationArgs['tuple']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)']
      /**
       * The ConditionalClauseStruct containing the clause's information
       */
      returns: ResponsiveDonationReturns['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)']
    }>
    & Record<'get_pending_events()uint64[]' | 'get_pending_events', {
      argsObj: ResponsiveDonationArgs['obj']['get_pending_events()uint64[]']
      argsTuple: ResponsiveDonationArgs['tuple']['get_pending_events()uint64[]']
      /**
       * Array of pending event IDs (empty for now - placeholder for interface)
       */
      returns: ResponsiveDonationReturns['get_pending_events()uint64[]']
    }>
    & Record<'get_clauses_for_event(uint64)uint64[]' | 'get_clauses_for_event', {
      argsObj: ResponsiveDonationArgs['obj']['get_clauses_for_event(uint64)uint64[]']
      argsTuple: ResponsiveDonationArgs['tuple']['get_clauses_for_event(uint64)uint64[]']
      /**
       * Array of clause IDs that depend on this event
       */
      returns: ResponsiveDonationReturns['get_clauses_for_event(uint64)uint64[]']
    }>
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    box: {
      keys: {}
      maps: {
        listedEvents: Map<bigint | number, EventStruct>
        conditionalClauses: Map<bigint | number, ConditionalClauseStruct>
        eventClauses: Map<bigint | number, bigint[]>
      }
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type ResponsiveDonationSignatures = keyof ResponsiveDonationTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type ResponsiveDonationNonVoidMethodSignatures = keyof ResponsiveDonationTypes['methods'] extends infer T ? T extends keyof ResponsiveDonationTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the ResponsiveDonation smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends ResponsiveDonationSignatures> = ResponsiveDonationTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the ResponsiveDonation smart contract to the method's return type
 */
export type MethodReturn<TSignature extends ResponsiveDonationSignatures> = ResponsiveDonationTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = ResponsiveDonationTypes['state']['box']['keys']


/**
 * Defines supported create method params for this smart contract
 */
export type ResponsiveDonationCreateCallParams =
  | Expand<AppClientBareCallParams & {method?: never} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines arguments required for the deploy method.
 */
export type ResponsiveDonationDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: ResponsiveDonationCreateCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the ResponsiveDonation smart contract
 */
export abstract class ResponsiveDonationParamsFactory {
  /**
   * Constructs a no op call for the create_event(string,address)uint64 ABI method
   *
   * Create a new event that can be used for conditional donations.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static createEvent(params: CallParams<ResponsiveDonationArgs['obj']['create_event(string,address)uint64'] | ResponsiveDonationArgs['tuple']['create_event(string,address)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'create_event(string,address)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.eventString, params.args.oracleAddress],
    }
  }
  /**
   * Constructs a no op call for the instantaneous_payout(address,pay)bool ABI method
   *
  * Process an immediate donation with instant payout to recipient.
  Perfect for direct charitable giving with immediate impact.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static instantaneousPayout(params: CallParams<ResponsiveDonationArgs['obj']['instantaneous_payout(address,pay)bool'] | ResponsiveDonationArgs['tuple']['instantaneous_payout(address,pay)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'instantaneous_payout(address,pay)bool' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.recipientAddress, params.args.payment],
    }
  }
  /**
   * Constructs a no op call for the create_conditional_donation(uint64,address,address,pay)uint64 ABI method
   *
  * Create a conditional donation that will pay out based on event resolution.
  Example: "Donate $1000 to Red Cross IF hurricane hits Miami, otherwise return to me"

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static createConditionalDonation(params: CallParams<ResponsiveDonationArgs['obj']['create_conditional_donation(uint64,address,address,pay)uint64'] | ResponsiveDonationArgs['tuple']['create_conditional_donation(uint64,address,address,pay)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'create_conditional_donation(uint64,address,address,pay)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.eventId, params.args.recipientYes, params.args.recipientNo, params.args.payment],
    }
  }
  /**
   * Constructs a no op call for the mixed_donation(address,uint64,uint64,address,address,pay)uint64 ABI method
   *
  * Create both instantaneous and conditional donations in a single transaction.
  Simplified version that handles one conditional donation to keep it simple.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mixedDonation(params: CallParams<ResponsiveDonationArgs['obj']['mixed_donation(address,uint64,uint64,address,address,pay)uint64'] | ResponsiveDonationArgs['tuple']['mixed_donation(address,uint64,uint64,address,address,pay)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'mixed_donation(address,uint64,uint64,address,address,pay)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.instantRecipient, params.args.instantAmount, params.args.eventId, params.args.recipientYes, params.args.recipientNo, params.args.payment],
    }
  }
  /**
   * Constructs a no op call for the resolve_event(uint64,bool)bool ABI method
   *
   * Resolve an event outcome. Can only be called by the authorized oracle.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static resolveEvent(params: CallParams<ResponsiveDonationArgs['obj']['resolve_event(uint64,bool)bool'] | ResponsiveDonationArgs['tuple']['resolve_event(uint64,bool)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'resolve_event(uint64,bool)bool' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.eventId, params.args.resolution],
    }
  }
  /**
   * Constructs a no op call for the execute_conditional_clause(uint64)bool ABI method
   *
  * Execute a conditional clause after its associated event has been resolved.
  Can be called by anyone to trigger payouts.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static executeConditionalClause(params: CallParams<ResponsiveDonationArgs['obj']['execute_conditional_clause(uint64)bool'] | ResponsiveDonationArgs['tuple']['execute_conditional_clause(uint64)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'execute_conditional_clause(uint64)bool' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.clauseId],
    }
  }
  /**
   * Constructs a no op call for the execute_clauses_for_event(uint64)uint64 ABI method
   *
  * Execute all unexecuted conditional clauses for a resolved event.
  This is more gas-efficient than executing clauses one by one.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static executeClausesForEvent(params: CallParams<ResponsiveDonationArgs['obj']['execute_clauses_for_event(uint64)uint64'] | ResponsiveDonationArgs['tuple']['execute_clauses_for_event(uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'execute_clauses_for_event(uint64)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.eventId],
    }
  }
  /**
   * Constructs a no op call for the get_event_info(uint64)(uint64,string,bool,bool,address) ABI method
   *
   * Get information about an event.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getEventInfo(params: CallParams<ResponsiveDonationArgs['obj']['get_event_info(uint64)(uint64,string,bool,bool,address)'] | ResponsiveDonationArgs['tuple']['get_event_info(uint64)(uint64,string,bool,bool,address)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_event_info(uint64)(uint64,string,bool,bool,address)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.eventId],
    }
  }
  /**
   * Constructs a no op call for the get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool) ABI method
   *
   * Get information about a conditional clause.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getClauseInfo(params: CallParams<ResponsiveDonationArgs['obj']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)'] | ResponsiveDonationArgs['tuple']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.clauseId],
    }
  }
  /**
   * Constructs a no op call for the get_pending_events()uint64[] ABI method
   *
  * Get all pending event IDs. Oracle can use this to know which events to monitor.
  Note: This is a simplified version - in production you'd want pagination for large numbers of events.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getPendingEvents(params: CallParams<ResponsiveDonationArgs['obj']['get_pending_events()uint64[]'] | ResponsiveDonationArgs['tuple']['get_pending_events()uint64[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_pending_events()uint64[]' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the get_clauses_for_event(uint64)uint64[] ABI method
   *
  * Get all clause IDs that depend on a specific event.
  Oracle can call this when resolving an event to get all clauses to execute.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getClausesForEvent(params: CallParams<ResponsiveDonationArgs['obj']['get_clauses_for_event(uint64)uint64[]'] | ResponsiveDonationArgs['tuple']['get_clauses_for_event(uint64)uint64[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_clauses_for_event(uint64)uint64[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.eventId],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the ResponsiveDonation smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class ResponsiveDonationFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `ResponsiveDonationFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new ResponsiveDonationClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new ResponsiveDonationClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the ResponsiveDonation smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: ResponsiveDonationDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
    })
    return { result: result.result, appClient: new ResponsiveDonationClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the ResponsiveDonation smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The params for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.params.bare.create(params)
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the ResponsiveDonation smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The transaction for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.createTransaction.bare.create(params)
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the ResponsiveDonation smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The create result
       */
      bare: async (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        const result = await this.appFactory.send.bare.create(params)
        return { result: result.result, appClient: new ResponsiveDonationClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the ResponsiveDonation smart contract
 */
export class ResponsiveDonationClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `ResponsiveDonationClient`
   *
   * @param appClient An `AppClient` instance which has been created with the ResponsiveDonation app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `ResponsiveDonationClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }
  
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends ResponsiveDonationNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }
  
  /**
   * Returns a new `ResponsiveDonationClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<ResponsiveDonationClient> {
    return new ResponsiveDonationClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `ResponsiveDonationClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<ResponsiveDonationClient> {
    return new ResponsiveDonationClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Makes a clear_state call to an existing instance of the ResponsiveDonation smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `create_event(string,address)uint64` ABI method.
     *
     * Create a new event that can be used for conditional donations.
     *
     * @param params The params for the smart contract call
     * @returns The call params: The event ID of the created event (uint64)
     */
    createEvent: (params: CallParams<ResponsiveDonationArgs['obj']['create_event(string,address)uint64'] | ResponsiveDonationArgs['tuple']['create_event(string,address)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ResponsiveDonationParamsFactory.createEvent(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `instantaneous_payout(address,pay)bool` ABI method.
     *
    * Process an immediate donation with instant payout to recipient.
    Perfect for direct charitable giving with immediate impact.

     *
     * @param params The params for the smart contract call
     * @returns The call params: True if the donation is successful
     */
    instantaneousPayout: (params: CallParams<ResponsiveDonationArgs['obj']['instantaneous_payout(address,pay)bool'] | ResponsiveDonationArgs['tuple']['instantaneous_payout(address,pay)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ResponsiveDonationParamsFactory.instantaneousPayout(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `create_conditional_donation(uint64,address,address,pay)uint64` ABI method.
     *
    * Create a conditional donation that will pay out based on event resolution.
    Example: "Donate $1000 to Red Cross IF hurricane hits Miami, otherwise return to me"

     *
     * @param params The params for the smart contract call
     * @returns The call params: The clause ID of the created conditional donation
     */
    createConditionalDonation: (params: CallParams<ResponsiveDonationArgs['obj']['create_conditional_donation(uint64,address,address,pay)uint64'] | ResponsiveDonationArgs['tuple']['create_conditional_donation(uint64,address,address,pay)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ResponsiveDonationParamsFactory.createConditionalDonation(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `mixed_donation(address,uint64,uint64,address,address,pay)uint64` ABI method.
     *
    * Create both instantaneous and conditional donations in a single transaction.
    Simplified version that handles one conditional donation to keep it simple.

     *
     * @param params The params for the smart contract call
     * @returns The call params: The clause ID for the conditional donation created
     */
    mixedDonation: (params: CallParams<ResponsiveDonationArgs['obj']['mixed_donation(address,uint64,uint64,address,address,pay)uint64'] | ResponsiveDonationArgs['tuple']['mixed_donation(address,uint64,uint64,address,address,pay)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ResponsiveDonationParamsFactory.mixedDonation(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `resolve_event(uint64,bool)bool` ABI method.
     *
     * Resolve an event outcome. Can only be called by the authorized oracle.
     *
     * @param params The params for the smart contract call
     * @returns The call params: True if the event is successfully resolved
     */
    resolveEvent: (params: CallParams<ResponsiveDonationArgs['obj']['resolve_event(uint64,bool)bool'] | ResponsiveDonationArgs['tuple']['resolve_event(uint64,bool)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ResponsiveDonationParamsFactory.resolveEvent(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `execute_conditional_clause(uint64)bool` ABI method.
     *
    * Execute a conditional clause after its associated event has been resolved.
    Can be called by anyone to trigger payouts.

     *
     * @param params The params for the smart contract call
     * @returns The call params: True if the clause is successfully executed
     */
    executeConditionalClause: (params: CallParams<ResponsiveDonationArgs['obj']['execute_conditional_clause(uint64)bool'] | ResponsiveDonationArgs['tuple']['execute_conditional_clause(uint64)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ResponsiveDonationParamsFactory.executeConditionalClause(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `execute_clauses_for_event(uint64)uint64` ABI method.
     *
    * Execute all unexecuted conditional clauses for a resolved event.
    This is more gas-efficient than executing clauses one by one.

     *
     * @param params The params for the smart contract call
     * @returns The call params: Number of clauses executed
     */
    executeClausesForEvent: (params: CallParams<ResponsiveDonationArgs['obj']['execute_clauses_for_event(uint64)uint64'] | ResponsiveDonationArgs['tuple']['execute_clauses_for_event(uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ResponsiveDonationParamsFactory.executeClausesForEvent(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `get_event_info(uint64)(uint64,string,bool,bool,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get information about an event.
     *
     * @param params The params for the smart contract call
     * @returns The call params: The EventStruct containing the event's information
     */
    getEventInfo: (params: CallParams<ResponsiveDonationArgs['obj']['get_event_info(uint64)(uint64,string,bool,bool,address)'] | ResponsiveDonationArgs['tuple']['get_event_info(uint64)(uint64,string,bool,bool,address)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ResponsiveDonationParamsFactory.getEventInfo(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get information about a conditional clause.
     *
     * @param params The params for the smart contract call
     * @returns The call params: The ConditionalClauseStruct containing the clause's information
     */
    getClauseInfo: (params: CallParams<ResponsiveDonationArgs['obj']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)'] | ResponsiveDonationArgs['tuple']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ResponsiveDonationParamsFactory.getClauseInfo(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `get_pending_events()uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Get all pending event IDs. Oracle can use this to know which events to monitor.
    Note: This is a simplified version - in production you'd want pagination for large numbers of events.

     *
     * @param params The params for the smart contract call
     * @returns The call params: Array of pending event IDs (empty for now - placeholder for interface)
     */
    getPendingEvents: (params: CallParams<ResponsiveDonationArgs['obj']['get_pending_events()uint64[]'] | ResponsiveDonationArgs['tuple']['get_pending_events()uint64[]']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(ResponsiveDonationParamsFactory.getPendingEvents(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `get_clauses_for_event(uint64)uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Get all clause IDs that depend on a specific event.
    Oracle can call this when resolving an event to get all clauses to execute.

     *
     * @param params The params for the smart contract call
     * @returns The call params: Array of clause IDs that depend on this event
     */
    getClausesForEvent: (params: CallParams<ResponsiveDonationArgs['obj']['get_clauses_for_event(uint64)uint64[]'] | ResponsiveDonationArgs['tuple']['get_clauses_for_event(uint64)uint64[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ResponsiveDonationParamsFactory.getClausesForEvent(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the ResponsiveDonation smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `create_event(string,address)uint64` ABI method.
     *
     * Create a new event that can be used for conditional donations.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The event ID of the created event (uint64)
     */
    createEvent: (params: CallParams<ResponsiveDonationArgs['obj']['create_event(string,address)uint64'] | ResponsiveDonationArgs['tuple']['create_event(string,address)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ResponsiveDonationParamsFactory.createEvent(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `instantaneous_payout(address,pay)bool` ABI method.
     *
    * Process an immediate donation with instant payout to recipient.
    Perfect for direct charitable giving with immediate impact.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: True if the donation is successful
     */
    instantaneousPayout: (params: CallParams<ResponsiveDonationArgs['obj']['instantaneous_payout(address,pay)bool'] | ResponsiveDonationArgs['tuple']['instantaneous_payout(address,pay)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ResponsiveDonationParamsFactory.instantaneousPayout(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `create_conditional_donation(uint64,address,address,pay)uint64` ABI method.
     *
    * Create a conditional donation that will pay out based on event resolution.
    Example: "Donate $1000 to Red Cross IF hurricane hits Miami, otherwise return to me"

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The clause ID of the created conditional donation
     */
    createConditionalDonation: (params: CallParams<ResponsiveDonationArgs['obj']['create_conditional_donation(uint64,address,address,pay)uint64'] | ResponsiveDonationArgs['tuple']['create_conditional_donation(uint64,address,address,pay)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ResponsiveDonationParamsFactory.createConditionalDonation(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `mixed_donation(address,uint64,uint64,address,address,pay)uint64` ABI method.
     *
    * Create both instantaneous and conditional donations in a single transaction.
    Simplified version that handles one conditional donation to keep it simple.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The clause ID for the conditional donation created
     */
    mixedDonation: (params: CallParams<ResponsiveDonationArgs['obj']['mixed_donation(address,uint64,uint64,address,address,pay)uint64'] | ResponsiveDonationArgs['tuple']['mixed_donation(address,uint64,uint64,address,address,pay)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ResponsiveDonationParamsFactory.mixedDonation(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `resolve_event(uint64,bool)bool` ABI method.
     *
     * Resolve an event outcome. Can only be called by the authorized oracle.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: True if the event is successfully resolved
     */
    resolveEvent: (params: CallParams<ResponsiveDonationArgs['obj']['resolve_event(uint64,bool)bool'] | ResponsiveDonationArgs['tuple']['resolve_event(uint64,bool)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ResponsiveDonationParamsFactory.resolveEvent(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `execute_conditional_clause(uint64)bool` ABI method.
     *
    * Execute a conditional clause after its associated event has been resolved.
    Can be called by anyone to trigger payouts.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: True if the clause is successfully executed
     */
    executeConditionalClause: (params: CallParams<ResponsiveDonationArgs['obj']['execute_conditional_clause(uint64)bool'] | ResponsiveDonationArgs['tuple']['execute_conditional_clause(uint64)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ResponsiveDonationParamsFactory.executeConditionalClause(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `execute_clauses_for_event(uint64)uint64` ABI method.
     *
    * Execute all unexecuted conditional clauses for a resolved event.
    This is more gas-efficient than executing clauses one by one.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Number of clauses executed
     */
    executeClausesForEvent: (params: CallParams<ResponsiveDonationArgs['obj']['execute_clauses_for_event(uint64)uint64'] | ResponsiveDonationArgs['tuple']['execute_clauses_for_event(uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ResponsiveDonationParamsFactory.executeClausesForEvent(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `get_event_info(uint64)(uint64,string,bool,bool,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get information about an event.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The EventStruct containing the event's information
     */
    getEventInfo: (params: CallParams<ResponsiveDonationArgs['obj']['get_event_info(uint64)(uint64,string,bool,bool,address)'] | ResponsiveDonationArgs['tuple']['get_event_info(uint64)(uint64,string,bool,bool,address)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ResponsiveDonationParamsFactory.getEventInfo(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get information about a conditional clause.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The ConditionalClauseStruct containing the clause's information
     */
    getClauseInfo: (params: CallParams<ResponsiveDonationArgs['obj']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)'] | ResponsiveDonationArgs['tuple']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ResponsiveDonationParamsFactory.getClauseInfo(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `get_pending_events()uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Get all pending event IDs. Oracle can use this to know which events to monitor.
    Note: This is a simplified version - in production you'd want pagination for large numbers of events.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Array of pending event IDs (empty for now - placeholder for interface)
     */
    getPendingEvents: (params: CallParams<ResponsiveDonationArgs['obj']['get_pending_events()uint64[]'] | ResponsiveDonationArgs['tuple']['get_pending_events()uint64[]']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(ResponsiveDonationParamsFactory.getPendingEvents(params))
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `get_clauses_for_event(uint64)uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Get all clause IDs that depend on a specific event.
    Oracle can call this when resolving an event to get all clauses to execute.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Array of clause IDs that depend on this event
     */
    getClausesForEvent: (params: CallParams<ResponsiveDonationArgs['obj']['get_clauses_for_event(uint64)uint64[]'] | ResponsiveDonationArgs['tuple']['get_clauses_for_event(uint64)uint64[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ResponsiveDonationParamsFactory.getClausesForEvent(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Makes a clear_state call to an existing instance of the ResponsiveDonation smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `create_event(string,address)uint64` ABI method.
     *
     * Create a new event that can be used for conditional donations.
     *
     * @param params The params for the smart contract call
     * @returns The call result: The event ID of the created event (uint64)
     */
    createEvent: async (params: CallParams<ResponsiveDonationArgs['obj']['create_event(string,address)uint64'] | ResponsiveDonationArgs['tuple']['create_event(string,address)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.createEvent(params))
      return {...result, return: result.return as unknown as (undefined | ResponsiveDonationReturns['create_event(string,address)uint64'])}
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `instantaneous_payout(address,pay)bool` ABI method.
     *
    * Process an immediate donation with instant payout to recipient.
    Perfect for direct charitable giving with immediate impact.

     *
     * @param params The params for the smart contract call
     * @returns The call result: True if the donation is successful
     */
    instantaneousPayout: async (params: CallParams<ResponsiveDonationArgs['obj']['instantaneous_payout(address,pay)bool'] | ResponsiveDonationArgs['tuple']['instantaneous_payout(address,pay)bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.instantaneousPayout(params))
      return {...result, return: result.return as unknown as (undefined | ResponsiveDonationReturns['instantaneous_payout(address,pay)bool'])}
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `create_conditional_donation(uint64,address,address,pay)uint64` ABI method.
     *
    * Create a conditional donation that will pay out based on event resolution.
    Example: "Donate $1000 to Red Cross IF hurricane hits Miami, otherwise return to me"

     *
     * @param params The params for the smart contract call
     * @returns The call result: The clause ID of the created conditional donation
     */
    createConditionalDonation: async (params: CallParams<ResponsiveDonationArgs['obj']['create_conditional_donation(uint64,address,address,pay)uint64'] | ResponsiveDonationArgs['tuple']['create_conditional_donation(uint64,address,address,pay)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.createConditionalDonation(params))
      return {...result, return: result.return as unknown as (undefined | ResponsiveDonationReturns['create_conditional_donation(uint64,address,address,pay)uint64'])}
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `mixed_donation(address,uint64,uint64,address,address,pay)uint64` ABI method.
     *
    * Create both instantaneous and conditional donations in a single transaction.
    Simplified version that handles one conditional donation to keep it simple.

     *
     * @param params The params for the smart contract call
     * @returns The call result: The clause ID for the conditional donation created
     */
    mixedDonation: async (params: CallParams<ResponsiveDonationArgs['obj']['mixed_donation(address,uint64,uint64,address,address,pay)uint64'] | ResponsiveDonationArgs['tuple']['mixed_donation(address,uint64,uint64,address,address,pay)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.mixedDonation(params))
      return {...result, return: result.return as unknown as (undefined | ResponsiveDonationReturns['mixed_donation(address,uint64,uint64,address,address,pay)uint64'])}
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `resolve_event(uint64,bool)bool` ABI method.
     *
     * Resolve an event outcome. Can only be called by the authorized oracle.
     *
     * @param params The params for the smart contract call
     * @returns The call result: True if the event is successfully resolved
     */
    resolveEvent: async (params: CallParams<ResponsiveDonationArgs['obj']['resolve_event(uint64,bool)bool'] | ResponsiveDonationArgs['tuple']['resolve_event(uint64,bool)bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.resolveEvent(params))
      return {...result, return: result.return as unknown as (undefined | ResponsiveDonationReturns['resolve_event(uint64,bool)bool'])}
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `execute_conditional_clause(uint64)bool` ABI method.
     *
    * Execute a conditional clause after its associated event has been resolved.
    Can be called by anyone to trigger payouts.

     *
     * @param params The params for the smart contract call
     * @returns The call result: True if the clause is successfully executed
     */
    executeConditionalClause: async (params: CallParams<ResponsiveDonationArgs['obj']['execute_conditional_clause(uint64)bool'] | ResponsiveDonationArgs['tuple']['execute_conditional_clause(uint64)bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.executeConditionalClause(params))
      return {...result, return: result.return as unknown as (undefined | ResponsiveDonationReturns['execute_conditional_clause(uint64)bool'])}
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `execute_clauses_for_event(uint64)uint64` ABI method.
     *
    * Execute all unexecuted conditional clauses for a resolved event.
    This is more gas-efficient than executing clauses one by one.

     *
     * @param params The params for the smart contract call
     * @returns The call result: Number of clauses executed
     */
    executeClausesForEvent: async (params: CallParams<ResponsiveDonationArgs['obj']['execute_clauses_for_event(uint64)uint64'] | ResponsiveDonationArgs['tuple']['execute_clauses_for_event(uint64)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.executeClausesForEvent(params))
      return {...result, return: result.return as unknown as (undefined | ResponsiveDonationReturns['execute_clauses_for_event(uint64)uint64'])}
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `get_event_info(uint64)(uint64,string,bool,bool,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get information about an event.
     *
     * @param params The params for the smart contract call
     * @returns The call result: The EventStruct containing the event's information
     */
    getEventInfo: async (params: CallParams<ResponsiveDonationArgs['obj']['get_event_info(uint64)(uint64,string,bool,bool,address)'] | ResponsiveDonationArgs['tuple']['get_event_info(uint64)(uint64,string,bool,bool,address)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.getEventInfo(params))
      return {...result, return: result.return as unknown as (undefined | ResponsiveDonationReturns['get_event_info(uint64)(uint64,string,bool,bool,address)'])}
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get information about a conditional clause.
     *
     * @param params The params for the smart contract call
     * @returns The call result: The ConditionalClauseStruct containing the clause's information
     */
    getClauseInfo: async (params: CallParams<ResponsiveDonationArgs['obj']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)'] | ResponsiveDonationArgs['tuple']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.getClauseInfo(params))
      return {...result, return: result.return as unknown as (undefined | ResponsiveDonationReturns['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)'])}
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `get_pending_events()uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Get all pending event IDs. Oracle can use this to know which events to monitor.
    Note: This is a simplified version - in production you'd want pagination for large numbers of events.

     *
     * @param params The params for the smart contract call
     * @returns The call result: Array of pending event IDs (empty for now - placeholder for interface)
     */
    getPendingEvents: async (params: CallParams<ResponsiveDonationArgs['obj']['get_pending_events()uint64[]'] | ResponsiveDonationArgs['tuple']['get_pending_events()uint64[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.getPendingEvents(params))
      return {...result, return: result.return as unknown as (undefined | ResponsiveDonationReturns['get_pending_events()uint64[]'])}
    },

    /**
     * Makes a call to the ResponsiveDonation smart contract using the `get_clauses_for_event(uint64)uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Get all clause IDs that depend on a specific event.
    Oracle can call this when resolving an event to get all clauses to execute.

     *
     * @param params The params for the smart contract call
     * @returns The call result: Array of clause IDs that depend on this event
     */
    getClausesForEvent: async (params: CallParams<ResponsiveDonationArgs['obj']['get_clauses_for_event(uint64)uint64[]'] | ResponsiveDonationArgs['tuple']['get_clauses_for_event(uint64)uint64[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.getClausesForEvent(params))
      return {...result, return: result.return as unknown as (undefined | ResponsiveDonationReturns['get_clauses_for_event(uint64)uint64[]'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new ResponsiveDonationClient(this.appClient.clone(params))
  }

  /**
   * Makes a readonly (simulated) call to the ResponsiveDonation smart contract using the `get_event_info(uint64)(uint64,string,bool,bool,address)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get information about an event.
   *
   * @param params The params for the smart contract call
   * @returns The call result: The EventStruct containing the event's information
   */
  async getEventInfo(params: CallParams<ResponsiveDonationArgs['obj']['get_event_info(uint64)(uint64,string,bool,bool,address)'] | ResponsiveDonationArgs['tuple']['get_event_info(uint64)(uint64,string,bool,bool,address)']>) {
    const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.getEventInfo(params))
    return result.return as unknown as ResponsiveDonationReturns['get_event_info(uint64)(uint64,string,bool,bool,address)']
  }

  /**
   * Makes a readonly (simulated) call to the ResponsiveDonation smart contract using the `get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get information about a conditional clause.
   *
   * @param params The params for the smart contract call
   * @returns The call result: The ConditionalClauseStruct containing the clause's information
   */
  async getClauseInfo(params: CallParams<ResponsiveDonationArgs['obj']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)'] | ResponsiveDonationArgs['tuple']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)']>) {
    const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.getClauseInfo(params))
    return result.return as unknown as ResponsiveDonationReturns['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)']
  }

  /**
   * Makes a readonly (simulated) call to the ResponsiveDonation smart contract using the `get_pending_events()uint64[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Get all pending event IDs. Oracle can use this to know which events to monitor.
  Note: This is a simplified version - in production you'd want pagination for large numbers of events.

   *
   * @param params The params for the smart contract call
   * @returns The call result: Array of pending event IDs (empty for now - placeholder for interface)
   */
  async getPendingEvents(params: CallParams<ResponsiveDonationArgs['obj']['get_pending_events()uint64[]'] | ResponsiveDonationArgs['tuple']['get_pending_events()uint64[]']> = {args: []}) {
    const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.getPendingEvents(params))
    return result.return as unknown as ResponsiveDonationReturns['get_pending_events()uint64[]']
  }

  /**
   * Makes a readonly (simulated) call to the ResponsiveDonation smart contract using the `get_clauses_for_event(uint64)uint64[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Get all clause IDs that depend on a specific event.
  Oracle can call this when resolving an event to get all clauses to execute.

   *
   * @param params The params for the smart contract call
   * @returns The call result: Array of clause IDs that depend on this event
   */
  async getClausesForEvent(params: CallParams<ResponsiveDonationArgs['obj']['get_clauses_for_event(uint64)uint64[]'] | ResponsiveDonationArgs['tuple']['get_clauses_for_event(uint64)uint64[]']>) {
    const result = await this.appClient.send.call(ResponsiveDonationParamsFactory.getClausesForEvent(params))
    return result.return as unknown as ResponsiveDonationReturns['get_clauses_for_event(uint64)uint64[]']
  }

  /**
   * Methods to access state for the current ResponsiveDonation app
   */
  state = {
    /**
     * Methods to access box state for the current ResponsiveDonation app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll()
        return {
        }
      },
      /**
       * Get values from the listed_events map in box state
       */
      listedEvents: {
        /**
         * Get all current values of the listed_events map in box state
         */
        getMap: async (): Promise<Map<bigint, EventStruct>> => { return (await this.appClient.state.box.getMap("listed_events")) as Map<bigint, EventStruct> },
        /**
         * Get a current value of the listed_events map by key from box state
         */
        value: async (key: bigint | number): Promise<EventStruct | undefined> => { return await this.appClient.state.box.getMapValue("listed_events", key) as EventStruct | undefined },
      },
      /**
       * Get values from the conditional_clauses map in box state
       */
      conditionalClauses: {
        /**
         * Get all current values of the conditional_clauses map in box state
         */
        getMap: async (): Promise<Map<bigint, ConditionalClauseStruct>> => { return (await this.appClient.state.box.getMap("conditional_clauses")) as Map<bigint, ConditionalClauseStruct> },
        /**
         * Get a current value of the conditional_clauses map by key from box state
         */
        value: async (key: bigint | number): Promise<ConditionalClauseStruct | undefined> => { return await this.appClient.state.box.getMapValue("conditional_clauses", key) as ConditionalClauseStruct | undefined },
      },
      /**
       * Get values from the event_clauses map in box state
       */
      eventClauses: {
        /**
         * Get all current values of the event_clauses map in box state
         */
        getMap: async (): Promise<Map<bigint, bigint[]>> => { return (await this.appClient.state.box.getMap("event_clauses")) as Map<bigint, bigint[]> },
        /**
         * Get a current value of the event_clauses map by key from box state
         */
        value: async (key: bigint | number): Promise<bigint[] | undefined> => { return await this.appClient.state.box.getMapValue("event_clauses", key) as bigint[] | undefined },
      },
    },
  }

  public newGroup(): ResponsiveDonationComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a create_event(string,address)uint64 method call against the ResponsiveDonation contract
       */
      createEvent(params: CallParams<ResponsiveDonationArgs['obj']['create_event(string,address)uint64'] | ResponsiveDonationArgs['tuple']['create_event(string,address)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.createEvent(params)))
        resultMappers.push((v) => client.decodeReturnValue('create_event(string,address)uint64', v))
        return this
      },
      /**
       * Add a instantaneous_payout(address,pay)bool method call against the ResponsiveDonation contract
       */
      instantaneousPayout(params: CallParams<ResponsiveDonationArgs['obj']['instantaneous_payout(address,pay)bool'] | ResponsiveDonationArgs['tuple']['instantaneous_payout(address,pay)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.instantaneousPayout(params)))
        resultMappers.push((v) => client.decodeReturnValue('instantaneous_payout(address,pay)bool', v))
        return this
      },
      /**
       * Add a create_conditional_donation(uint64,address,address,pay)uint64 method call against the ResponsiveDonation contract
       */
      createConditionalDonation(params: CallParams<ResponsiveDonationArgs['obj']['create_conditional_donation(uint64,address,address,pay)uint64'] | ResponsiveDonationArgs['tuple']['create_conditional_donation(uint64,address,address,pay)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.createConditionalDonation(params)))
        resultMappers.push((v) => client.decodeReturnValue('create_conditional_donation(uint64,address,address,pay)uint64', v))
        return this
      },
      /**
       * Add a mixed_donation(address,uint64,uint64,address,address,pay)uint64 method call against the ResponsiveDonation contract
       */
      mixedDonation(params: CallParams<ResponsiveDonationArgs['obj']['mixed_donation(address,uint64,uint64,address,address,pay)uint64'] | ResponsiveDonationArgs['tuple']['mixed_donation(address,uint64,uint64,address,address,pay)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mixedDonation(params)))
        resultMappers.push((v) => client.decodeReturnValue('mixed_donation(address,uint64,uint64,address,address,pay)uint64', v))
        return this
      },
      /**
       * Add a resolve_event(uint64,bool)bool method call against the ResponsiveDonation contract
       */
      resolveEvent(params: CallParams<ResponsiveDonationArgs['obj']['resolve_event(uint64,bool)bool'] | ResponsiveDonationArgs['tuple']['resolve_event(uint64,bool)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.resolveEvent(params)))
        resultMappers.push((v) => client.decodeReturnValue('resolve_event(uint64,bool)bool', v))
        return this
      },
      /**
       * Add a execute_conditional_clause(uint64)bool method call against the ResponsiveDonation contract
       */
      executeConditionalClause(params: CallParams<ResponsiveDonationArgs['obj']['execute_conditional_clause(uint64)bool'] | ResponsiveDonationArgs['tuple']['execute_conditional_clause(uint64)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.executeConditionalClause(params)))
        resultMappers.push((v) => client.decodeReturnValue('execute_conditional_clause(uint64)bool', v))
        return this
      },
      /**
       * Add a execute_clauses_for_event(uint64)uint64 method call against the ResponsiveDonation contract
       */
      executeClausesForEvent(params: CallParams<ResponsiveDonationArgs['obj']['execute_clauses_for_event(uint64)uint64'] | ResponsiveDonationArgs['tuple']['execute_clauses_for_event(uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.executeClausesForEvent(params)))
        resultMappers.push((v) => client.decodeReturnValue('execute_clauses_for_event(uint64)uint64', v))
        return this
      },
      /**
       * Add a get_event_info(uint64)(uint64,string,bool,bool,address) method call against the ResponsiveDonation contract
       */
      getEventInfo(params: CallParams<ResponsiveDonationArgs['obj']['get_event_info(uint64)(uint64,string,bool,bool,address)'] | ResponsiveDonationArgs['tuple']['get_event_info(uint64)(uint64,string,bool,bool,address)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getEventInfo(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_event_info(uint64)(uint64,string,bool,bool,address)', v))
        return this
      },
      /**
       * Add a get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool) method call against the ResponsiveDonation contract
       */
      getClauseInfo(params: CallParams<ResponsiveDonationArgs['obj']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)'] | ResponsiveDonationArgs['tuple']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getClauseInfo(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)', v))
        return this
      },
      /**
       * Add a get_pending_events()uint64[] method call against the ResponsiveDonation contract
       */
      getPendingEvents(params: CallParams<ResponsiveDonationArgs['obj']['get_pending_events()uint64[]'] | ResponsiveDonationArgs['tuple']['get_pending_events()uint64[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getPendingEvents(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_pending_events()uint64[]', v))
        return this
      },
      /**
       * Add a get_clauses_for_event(uint64)uint64[] method call against the ResponsiveDonation contract
       */
      getClausesForEvent(params: CallParams<ResponsiveDonationArgs['obj']['get_clauses_for_event(uint64)uint64[]'] | ResponsiveDonationArgs['tuple']['get_clauses_for_event(uint64)uint64[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getClausesForEvent(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_clauses_for_event(uint64)uint64[]', v))
        return this
      },
      /**
       * Add a clear state call to the ResponsiveDonation contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as ResponsiveDonationComposer
  }
}
export type ResponsiveDonationComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the create_event(string,address)uint64 ABI method.
   *
   * Create a new event that can be used for conditional donations.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  createEvent(params?: CallParams<ResponsiveDonationArgs['obj']['create_event(string,address)uint64'] | ResponsiveDonationArgs['tuple']['create_event(string,address)uint64']>): ResponsiveDonationComposer<[...TReturns, ResponsiveDonationReturns['create_event(string,address)uint64'] | undefined]>

  /**
   * Calls the instantaneous_payout(address,pay)bool ABI method.
   *
  * Process an immediate donation with instant payout to recipient.
  Perfect for direct charitable giving with immediate impact.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  instantaneousPayout(params?: CallParams<ResponsiveDonationArgs['obj']['instantaneous_payout(address,pay)bool'] | ResponsiveDonationArgs['tuple']['instantaneous_payout(address,pay)bool']>): ResponsiveDonationComposer<[...TReturns, ResponsiveDonationReturns['instantaneous_payout(address,pay)bool'] | undefined]>

  /**
   * Calls the create_conditional_donation(uint64,address,address,pay)uint64 ABI method.
   *
  * Create a conditional donation that will pay out based on event resolution.
  Example: "Donate $1000 to Red Cross IF hurricane hits Miami, otherwise return to me"

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  createConditionalDonation(params?: CallParams<ResponsiveDonationArgs['obj']['create_conditional_donation(uint64,address,address,pay)uint64'] | ResponsiveDonationArgs['tuple']['create_conditional_donation(uint64,address,address,pay)uint64']>): ResponsiveDonationComposer<[...TReturns, ResponsiveDonationReturns['create_conditional_donation(uint64,address,address,pay)uint64'] | undefined]>

  /**
   * Calls the mixed_donation(address,uint64,uint64,address,address,pay)uint64 ABI method.
   *
  * Create both instantaneous and conditional donations in a single transaction.
  Simplified version that handles one conditional donation to keep it simple.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  mixedDonation(params?: CallParams<ResponsiveDonationArgs['obj']['mixed_donation(address,uint64,uint64,address,address,pay)uint64'] | ResponsiveDonationArgs['tuple']['mixed_donation(address,uint64,uint64,address,address,pay)uint64']>): ResponsiveDonationComposer<[...TReturns, ResponsiveDonationReturns['mixed_donation(address,uint64,uint64,address,address,pay)uint64'] | undefined]>

  /**
   * Calls the resolve_event(uint64,bool)bool ABI method.
   *
   * Resolve an event outcome. Can only be called by the authorized oracle.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  resolveEvent(params?: CallParams<ResponsiveDonationArgs['obj']['resolve_event(uint64,bool)bool'] | ResponsiveDonationArgs['tuple']['resolve_event(uint64,bool)bool']>): ResponsiveDonationComposer<[...TReturns, ResponsiveDonationReturns['resolve_event(uint64,bool)bool'] | undefined]>

  /**
   * Calls the execute_conditional_clause(uint64)bool ABI method.
   *
  * Execute a conditional clause after its associated event has been resolved.
  Can be called by anyone to trigger payouts.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  executeConditionalClause(params?: CallParams<ResponsiveDonationArgs['obj']['execute_conditional_clause(uint64)bool'] | ResponsiveDonationArgs['tuple']['execute_conditional_clause(uint64)bool']>): ResponsiveDonationComposer<[...TReturns, ResponsiveDonationReturns['execute_conditional_clause(uint64)bool'] | undefined]>

  /**
   * Calls the execute_clauses_for_event(uint64)uint64 ABI method.
   *
  * Execute all unexecuted conditional clauses for a resolved event.
  This is more gas-efficient than executing clauses one by one.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  executeClausesForEvent(params?: CallParams<ResponsiveDonationArgs['obj']['execute_clauses_for_event(uint64)uint64'] | ResponsiveDonationArgs['tuple']['execute_clauses_for_event(uint64)uint64']>): ResponsiveDonationComposer<[...TReturns, ResponsiveDonationReturns['execute_clauses_for_event(uint64)uint64'] | undefined]>

  /**
   * Calls the get_event_info(uint64)(uint64,string,bool,bool,address) ABI method.
   *
   * Get information about an event.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getEventInfo(params?: CallParams<ResponsiveDonationArgs['obj']['get_event_info(uint64)(uint64,string,bool,bool,address)'] | ResponsiveDonationArgs['tuple']['get_event_info(uint64)(uint64,string,bool,bool,address)']>): ResponsiveDonationComposer<[...TReturns, ResponsiveDonationReturns['get_event_info(uint64)(uint64,string,bool,bool,address)'] | undefined]>

  /**
   * Calls the get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool) ABI method.
   *
   * Get information about a conditional clause.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getClauseInfo(params?: CallParams<ResponsiveDonationArgs['obj']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)'] | ResponsiveDonationArgs['tuple']['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)']>): ResponsiveDonationComposer<[...TReturns, ResponsiveDonationReturns['get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)'] | undefined]>

  /**
   * Calls the get_pending_events()uint64[] ABI method.
   *
  * Get all pending event IDs. Oracle can use this to know which events to monitor.
  Note: This is a simplified version - in production you'd want pagination for large numbers of events.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getPendingEvents(params?: CallParams<ResponsiveDonationArgs['obj']['get_pending_events()uint64[]'] | ResponsiveDonationArgs['tuple']['get_pending_events()uint64[]']>): ResponsiveDonationComposer<[...TReturns, ResponsiveDonationReturns['get_pending_events()uint64[]'] | undefined]>

  /**
   * Calls the get_clauses_for_event(uint64)uint64[] ABI method.
   *
  * Get all clause IDs that depend on a specific event.
  Oracle can call this when resolving an event to get all clauses to execute.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getClausesForEvent(params?: CallParams<ResponsiveDonationArgs['obj']['get_clauses_for_event(uint64)uint64[]'] | ResponsiveDonationArgs['tuple']['get_clauses_for_event(uint64)uint64[]']>): ResponsiveDonationComposer<[...TReturns, ResponsiveDonationReturns['get_clauses_for_event(uint64)uint64[]'] | undefined]>

  /**
   * Makes a clear_state call to an existing instance of the ResponsiveDonation smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): ResponsiveDonationComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): ResponsiveDonationComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<ResponsiveDonationComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<ResponsiveDonationComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<ResponsiveDonationComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<ResponsiveDonationComposerResults<TReturns>>
}
export type ResponsiveDonationComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

